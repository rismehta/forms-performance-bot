/**
 * Form-specific report generation for PR comments
 */
export class FormPRReporter {
  constructor(octokit, owner, repo, prNumber) {
    this.octokit = octokit;
    this.owner = owner;
    this.repo = repo;
    this.prNumber = prNumber;
  }

  /**
   * Generate and post the performance report
   */
  async generateReport(results, urls, prNumber, repo) {
    const report = this.buildMarkdownReport(results, urls, prNumber, repo);
    
    try {
      await this.postComment(report);
      console.log('Performance report posted successfully');
    } catch (error) {
      console.error('Error posting comment:', error.message);
      throw error;
    }
  }

  /**
   * Build the minimal markdown report for PR comment
   * Full details are in the HTML artifact
   */
  buildMarkdownReport(results, urls, prNumber, repo) {
    const sections = [];

    // Minimal header
    sections.push('## ðŸ” Performance Analysis\n');

    // Summary line
    const critical = this.countCriticalIssues(results);
    const warnings = this.countWarnings(results);
    const loadStatus = this.getLoadStatus(urls);
    
    sections.push(`${critical > 0 ? 'âŒ' : 'âœ…'} **${critical} Critical** | ${warnings > 0 ? 'âš ï¸' : 'âœ…'} **${warnings} Warnings** | â±ï¸ **Load: ${loadStatus}**\n`);

    // Auto-Fix PR (if available)
    if (urls.autoFixPR) {
      sections.push(`### âœ… Auto-Fix PR Ready\n`);
      sections.push(`[**PR #${urls.autoFixPR.number}**](${urls.autoFixPR.url}) contains ${urls.autoFixPR.filesChanged} automated fix(es) â†’ **Review & Merge**\n`);
      sections.push('---\n');
    }

    // Top 3-5 Critical Actions (if any)
    const topActions = this.buildTopActionsSection(results, urls);
    if (topActions) {
      sections.push('### ðŸŽ¯ Top Priority Actions\n');
      sections.push(topActions);
      sections.push('---\n');
    }

    // Quick Stats
    sections.push(this.buildQuickStatsSection(results, urls));

    // Link to full report (GitHub artifact)
    const runId = process.env.GITHUB_RUN_ID || 'latest';
    const artifactUrl = `https://github.com/${repo}/actions/runs/${runId}`;
    sections.push('\n---\n');
    sections.push(`ðŸ“Š **[View Full Report â†’](${artifactUrl})** â€” Click "Summary" â†’ Download "performance-report" artifact\n`);
    sections.push(`ðŸ“‹ **[Action Logs](${artifactUrl})** | ðŸ“– **[Documentation](https://github.com/rismehta/forms-performance-bot)**\n`);

    sections.push('\n---');
    sections.push('*Generated by AEM Forms Performance Analyzer*');

    return sections.join('\n');
  }

  /**
   * Build AI Auto-Fix Suggestions section
   */
  buildAutoFixSuggestionsSection(autoFixData, autoFixPR) {
    if (!autoFixData || !autoFixData.enabled || autoFixData.suggestions.length === 0) {
      return '';
    }

    const lines = ['### AI Auto-Fix Suggestions\n'];
    
    // AUTO-FIX PR LINK (show prominently at top if available)
    if (autoFixPR) {
      lines.push(`> ### Auto-Fix PR Created: [#${autoFixPR.number}](${autoFixPR.url})\n`);
      lines.push(`> **${autoFixPR.filesChanged} file(s) automatically annotated** â€” Comments and warnings added to flag issues\n`);
      lines.push('**Auto-applied annotations:**');
      autoFixPR.fixes.forEach((fix, i) => {
        lines.push(`${i + 1}. ${fix}`);
      });
      lines.push('');
      lines.push('**How to use:**');
      lines.push('1. Review the annotations in [Auto-Fix PR #' + autoFixPR.number + '](' + autoFixPR.url + ')');
      lines.push('2. Merge the PR to add warning comments to your code');
      lines.push('3. Follow the detailed refactoring guides below for each issue\n');
      lines.push('---\n');
    } else {
      lines.push(`> **${autoFixData.suggestions.length} performance improvement${autoFixData.suggestions.length > 1 ? 's' : ''} identified** â€” Review and apply to optimize your form\n`);
    }
    
    // Group by severity and fix type
    const critical = autoFixData.suggestions.filter(s => s.severity === 'critical');
    const high = autoFixData.suggestions.filter(s => s.severity === 'high');
    
    if (critical.length > 0) {
      lines.push('#### Critical Issues (Manual Refactoring Required)\n');
      lines.push('> These require code changes beyond simple comments. Follow the refactoring guides below.\n');
      critical.forEach((suggestion, index) => {
        lines.push(this.formatAutoFixSuggestion(suggestion, index + 1));
      });
    }
    
    if (high.length > 0) {
      lines.push('#### High Priority Issues\n');
      high.forEach((suggestion, index) => {
        lines.push(this.formatAutoFixSuggestion(suggestion, critical.length + index + 1));
      });
    }
    
    lines.push(`\n> *AI-powered fixes generated by ${autoFixData.provider === 'azure-openai' ? 'Azure OpenAI GPT-4.1' : autoFixData.provider}*\n`);
    
    return lines.join('\n');
  }

  /**
   * Format a single auto-fix suggestion
   */
  formatAutoFixSuggestion(suggestion, index) {
    const lines = [];
    
    lines.push(`<details>`);
    lines.push(`<summary><strong>${index}. ${suggestion.title}</strong></summary>\n`);
    
    lines.push(`**Issue:** ${suggestion.description}\n`);
    
    if (suggestion.estimatedImpact) {
      lines.push(`**Impact:** ${suggestion.estimatedImpact}\n`);
    }
    
    // JS Refactored Code (HTTP/DOM fixes) - MANUAL APPLICATION REQUIRED
    if (suggestion.refactoredCode) {
      lines.push(`**File:** \`${suggestion.file}:${suggestion.line || 1}\`\n`);
      lines.push(`**Suggested Refactor** (requires manual review):\n`);
      
      // Show refactored code (manual application required)
      lines.push('```javascript');
      lines.push(suggestion.refactoredCode);
      lines.push('```\n');
      
      // Add form JSON if applicable (HTTP fixes)
      if (suggestion.formJsonSnippet) {
        lines.push(`**Step 2: Add to Form JSON (Form Editor or JSON)**\n`);
        lines.push('```json');
        lines.push(suggestion.formJsonSnippet);
        lines.push('```\n');
      }
      
      // Add component example if applicable (DOM fixes)
      if (suggestion.componentExample) {
        lines.push(`**Custom Component (if needed):**\n`);
        lines.push('```javascript');
        lines.push(suggestion.componentExample);
        lines.push('```\n');
      }
      
      // Add testing steps
      if (suggestion.testingSteps) {
        lines.push(`**Testing:**\n`);
        lines.push(suggestion.testingSteps);
        lines.push('\n');
      }
    }
    // CSS Fixes with code
    else if (suggestion.file && suggestion.originalCode && suggestion.fixedCode) {
      lines.push(`**File:** \`${suggestion.file}:${suggestion.line}\`\n`);
      
      lines.push(`**Current Code:**`);
      lines.push('```css');
      lines.push(suggestion.originalCode);
      lines.push('```\n');
      
      lines.push(`**Suggested Fix:**`);
      lines.push('```css');
      lines.push(suggestion.fixedCode);
      lines.push('```\n');
      
      if (suggestion.htmlSuggestion) {
        lines.push(`**HTML Alternative:**`);
        lines.push('```html');
        lines.push(suggestion.htmlSuggestion);
        lines.push('```\n');
      }
      
      if (suggestion.alternativeFix) {
        lines.push(`**Alternative:** ${suggestion.alternativeFix}\n`);
      }
    }
    // Guidance-only fixes (for complex issues)
    else if (suggestion.guidance) {
      lines.push(`**How to Fix:**`);
      lines.push(suggestion.guidance);
      lines.push('');
    }
    
    // Fields to remove (for hidden fields)
    if (suggestion.fieldsToRemove && suggestion.fieldsToRemove.length > 0) {
      lines.push(`**Fields to Remove:**`);
      lines.push(suggestion.fieldsToRemove.map(f => `- \`${f}\``).join('\n'));
      lines.push('');
    }
    
    lines.push(`</details>\n`);
    
    return lines.join('\n');
  }

  /**
   * Build performance metrics section (form load time)
   */
  buildPerformanceMetricsSection(beforeData, afterData) {
    const lines = ['###  Form Load Performance\n'];

    lines.push('| Metric | Before | After | Change | Status |');
    lines.push('|--------|--------|-------|--------|--------|');
    
    if (beforeData?.performanceMetrics && afterData?.performanceMetrics) {
      const before = beforeData.performanceMetrics;
      const after = afterData.performanceMetrics;
      
      const loadTimeDelta = after.loadTime - before.loadTime;
      const loadTimeChange = loadTimeDelta !== 0 ? `${loadTimeDelta > 0 ? '+' : ''}${loadTimeDelta}ms` : '0ms';
      
      // Determine status based on whether form rendered and load time
      let status = '';
      let beforeStatus = '';
      let afterStatus = '';
      
      // Check if forms actually loaded
      if (before.formRendered === false) {
        beforeStatus = ' (Failed)';
      }
      if (after.formRendered === false) {
        afterStatus = ' (Failed)';
        status = 'Failed';
      } else if (after.loadTime < 2000) {
        status = 'Fast';
      } else if (after.loadTime < 3000) {
        status = loadTimeDelta > 0 ? 'Slower' : 'Good';
      } else {
        status = 'Slow';
      }
      
      lines.push(`| **Form Render Time** | ${before.loadTime}ms${beforeStatus} | ${after.loadTime}ms${afterStatus} | ${loadTimeChange} | ${status} |`);
      
      if (before.Nodes && after.Nodes) {
        const nodesDelta = after.Nodes - before.Nodes;
        const nodesChange = nodesDelta !== 0 ? `${nodesDelta > 0 ? '+' : ''}${nodesDelta}` : '0';
        lines.push(`| **DOM Nodes** | ${before.Nodes} | ${after.Nodes} | ${nodesChange} | - |`);
      }
      
      if (before.JSHeapUsedSize && after.JSHeapUsedSize) {
        const heapBefore = (before.JSHeapUsedSize / 1024 / 1024).toFixed(1);
        const heapAfter = (after.JSHeapUsedSize / 1024 / 1024).toFixed(1);
        const heapDelta = ((after.JSHeapUsedSize - before.JSHeapUsedSize) / 1024 / 1024).toFixed(1);
        lines.push(`| **JS Heap Size** | ${heapBefore}MB | ${heapAfter}MB | ${heapDelta > 0 ? '+' : ''}${heapDelta}MB | - |`);
      }
    }
    
    return lines.join('\n');
  }

  /**
   * Build form structure section
   */
  buildFormStructureSection(formAnalysis) {
    const lines = ['### Form Structure\n'];

    if (formAnalysis.before && formAnalysis.after) {
      const { delta, newIssues, resolvedIssues } = formAnalysis;

      lines.push('| Metric | Before | After | Change |');
      lines.push('|--------|--------|-------|--------|');
      lines.push(`| Components | ${formAnalysis.before.components.total} | ${formAnalysis.after.components.total} | ${this.formatDelta(delta.components)} |`);
      lines.push(`| Event Handlers | ${formAnalysis.before.events.total} | ${formAnalysis.after.events.total} | ${this.formatDelta(delta.events)} |`);
      lines.push(`| Max Nesting Depth | ${formAnalysis.before.components.maxDepth} | ${formAnalysis.after.components.maxDepth} | ${this.formatDelta(delta.maxDepth)} |\n`);

      // New issues
      if (newIssues.length > 0) {
        lines.push('#### New Issues\n');
        newIssues.forEach(issue => {
          lines.push(`- **[${issue.severity.toUpperCase()}] ${issue.type}**: ${issue.message}`);
        });
        lines.push('');
      }

      // Resolved issues
      if (resolvedIssues.length > 0) {
        lines.push('#### Resolved Issues\n');
        resolvedIssues.forEach(issue => {
          lines.push(`- **${issue.type}**: ${issue.message}`);
        });
        lines.push('');
      }
    }

    return lines.join('\n');
  }

  /**
   * Build form events section (API calls in initialize)
   */
  buildFormEventsSection(formEvents) {
    const lines = ['### Form Events Analysis\n'];

    const { newIssues, resolvedIssues, after } = formEvents;

    // New issues - show concisely
    if (newIssues && newIssues.length > 0) {
      lines.push('####  Critical: API Calls in Initialize Events\n');
      lines.push(`**${newIssues.length} field(s) making API calls in initialize - this blocks form rendering:**\n`);
      
      // Group unique fields
      const uniqueFields = [...new Set(newIssues.map(i => i.field))];
      
      uniqueFields.forEach(field => {
        const apiCall = after.apiCallsInInitialize.find(a => a.field === field);
        if (apiCall) {
          lines.push(`- **\`${field}\`** (\`${apiCall.path}\`) - ${apiCall.apiCallType}`);
          lines.push(`  Expression: \`${apiCall.expression.substring(0, 80)}...\``);
        }
      });
      
      lines.push('');
      lines.push('** Recommendation:** Move API calls to custom events triggered **after** render, or use lazy loading. Initialize should only set up initial state, not fetch data.\n');
    }

    // Resolved issues
    if (resolvedIssues && resolvedIssues.length > 0) {
      lines.push('####  Fixed: API Calls Moved from Initialize\n');
      resolvedIssues.forEach(issue => {
        lines.push(`- Field \`${issue.field}\` - API call removed from initialize event`);
      });
      lines.push('');
    }

    if (!after || (after.apiCallsInInitialize && after.apiCallsInInitialize.length === 0)) {
      lines.push(' No API calls found in initialize events.\n');
    }

    return lines.join('\n');
  }

  /**
   * Build hidden fields section
   */
  buildHiddenFieldsSection(hiddenFields) {
    const lines = ['###  Hidden Fields Analysis\n'];

    const { delta, newIssues, resolvedIssues, after } = hiddenFields;

    if (after) {
      lines.push(`**Total Hidden Fields:** ${after.totalHiddenFields}`);
      lines.push(`**Unnecessary Hidden Fields:** ${after.unnecessaryHiddenFields}\n`);

      if (delta && (delta.hiddenFields !== 0 || delta.unnecessaryFields !== 0)) {
        lines.push('**Changes:**');
        if (delta.hiddenFields !== 0) {
          lines.push(`- Hidden fields: ${this.formatDelta(delta.hiddenFields)}`);
        }
        if (delta.unnecessaryFields !== 0) {
          lines.push(`- Unnecessary fields: ${this.formatDelta(delta.unnecessaryFields)}`);
        }
        lines.push('');
      }
    }

    // New issues - show concisely
    if (newIssues && newIssues.length > 0) {
      lines.push('####  Unnecessary Hidden Fields\n');
      
      // Show first 10 field names inline
      const visibleCount = Math.min(10, newIssues.length);
      const fieldNames = newIssues.slice(0, visibleCount).map(i => `\`${i.field}\``).join(', ');
      
      lines.push(`**${newIssues.length} field(s) are always hidden and never made visible:**\n`);
      lines.push(fieldNames + (newIssues.length > visibleCount ? ', ...' : '') + '\n');
      
      // Put remaining fields in collapsible section
      if (newIssues.length > visibleCount) {
        lines.push(`<details>\n<summary>Show all ${newIssues.length} fields</summary>\n`);
        const allFields = newIssues.map(i => `- \`${i.field}\``).join('\n');
        lines.push(allFields);
        lines.push('\n</details>\n');
      }
      
      lines.push('** Recommendation:** Remove these fields from the form JSON and store as Form variables instead. Hidden fields that are never shown bloat the DOM (each adds ~50-100 bytes) and slow down rendering.\n');
    }

    // Resolved issues
    if (resolvedIssues && resolvedIssues.length > 0) {
      lines.push(` **Fixed:** ${resolvedIssues.length} unnecessary hidden field(s) removed\n`);
    }

    if (!after || after.unnecessaryHiddenFields === 0) {
      lines.push(' No unnecessary hidden fields detected.\n');
    }

    return lines.join('\n');
  }

  /**
   * Build rule cycles section
   */
  buildRuleCyclesSection(ruleCycles) {
    const lines = ['###  Rule Performance Analysis\n'];

    const { newCycles, resolvedCycles, after, slowRules, slowRuleCount } = ruleCycles;

    // Handle error case first
    if (after && after.error) {
      lines.push(` Error analyzing rule cycles: ${after.error}\n`);
      return lines.join('\n');
    }

    // Show summary stats (always show if we have data)
    if (after) {
      lines.push(`**Total Rules:** ${after.totalRules || 0}`);
      lines.push(`**Fields with Rules:** ${after.fieldsWithRules || 0}`);
      lines.push(`**Circular Dependencies:** ${after.cycles || 0}`);
      if (slowRuleCount > 0) {
        lines.push(`**Slow Rules:** ${slowRuleCount} (> 50ms execution)\n`);
      } else {
        lines.push('');
      }
    }

    // Show slow rules first (these impact every interaction)
    if (slowRules && slowRules.length > 0) {
      lines.push('####  Slow Rule Execution\n');
      lines.push(`**${slowRuleCount} rule(s) take > 50ms to execute** - these slow down form interactions.\n`);
      
      // Show top 5 slowest
      const top5 = slowRules.slice(0, 5);
      top5.forEach(rule => {
        lines.push(`- **\`${rule.field}\`** - ${rule.duration}ms`);
        lines.push(`  Event: ${rule.event}, Expression: \`${rule.expression.substring(0, 60)}...\``);
      });
      
      if (slowRuleCount > 5) {
        lines.push(`\n*... and ${slowRuleCount - 5} more slow rule(s)*`);
      }
      
      lines.push('');
      lines.push('** Recommendation:** Optimize these rules by reducing complex computations, caching results, or moving expensive operations to custom events.\n');
    }

    // Show ALL cycles (from newCycles which contains after.cycleDetails)
    if (newCycles && newCycles.length > 0) {
      lines.push('####  Critical: Circular Dependencies Detected\n');
      
      newCycles.forEach((cycle, index) => {
        const cycleFields = cycle.fields || cycle.path || ['unknown'];
        lines.push(`**Cycle ${index + 1}:** \`${cycleFields.join(' â†’ ')}\``);
      });
      lines.push('');
      lines.push('** Recommendation:** Break circular dependencies immediately - these cause infinite loops and severely impact performance.\n');
    }

    // If no cycles detected, show success message
    if (!newCycles || newCycles.length === 0) {
      lines.push('No circular dependencies detected.\n');
    }

    // Resolved cycles
    if (resolvedCycles && resolvedCycles.length > 0) {
      lines.push('####  Resolved Circular Dependencies\n');
      resolvedCycles.forEach(cycle => {
        lines.push(`- \`${cycle.fields.join(' â†’ ')}\``);
      });
      lines.push('');
    }

    if (!after || (!after.error && (after.cycles === 0 || !after.cycles))) {
      lines.push(' No circular dependencies detected.\n');
    }

    return lines.join('\n');
  }

  /**
   * Build form HTML section
   */
  buildFormHTMLSection(formHTML, urls) {
    const lines = ['###  Form Rendering Performance\n'];

    const { newIssues, resolvedIssues, after, delta } = formHTML;
    
    // Check if form actually rendered
    const formRendered = urls?.afterData?.performanceMetrics?.formRendered !== false;

    if (!formRendered) {
      lines.push('** Form failed to render - HTML analysis unavailable**\n');
      lines.push('The form did not load within 15 seconds, so we cannot analyze the rendered HTML.');
      lines.push('See "Form Load Performance" section above for investigation steps.\n');
      return lines.join('\n');
    }

    if (after && after.rendering) {
      lines.push('**Rendered Form Analysis:**');
      lines.push(`- Total DOM Elements: ${after.rendering.totalElements}`);
      lines.push(`- Hidden Elements: ${after.rendering.hiddenElements}`);
      lines.push(`- Images: ${after.images.total} (${after.images.nonLazyLoaded} without lazy loading)`);
      lines.push(`- Blocking Scripts: ${after.scripts.blocking}\n`);

      if (delta) {
        const hasChanges = delta.images !== 0 || delta.nonLazyImages !== 0 || 
                          delta.totalElements !== 0 || delta.blockingScripts !== 0;
        
        if (hasChanges) {
          lines.push('**Changes:**');
          if (delta.images !== 0) {
            lines.push(`- Images: ${this.formatDelta(delta.images)}`);
          }
          if (delta.nonLazyImages !== 0) {
            lines.push(`- Non-lazy images: ${this.formatDelta(delta.nonLazyImages)}`);
          }
          if (delta.totalElements !== 0) {
            lines.push(`- DOM elements: ${this.formatDelta(delta.totalElements)}`);
          }
          if (delta.blockingScripts !== 0) {
            lines.push(`- Blocking scripts: ${this.formatDelta(delta.blockingScripts)}`);
          }
          lines.push('');
        }
      }
    }

    // New issues
    if (newIssues && newIssues.length > 0) {
      lines.push('####  Form Rendering Issues\n');
      newIssues.forEach(issue => {
        lines.push(`**${this.getSeverityEmoji(issue.severity)} ${issue.type}**`);
        lines.push(`- **Issue:** ${issue.message}`);
        if (issue.images && issue.images.length > 0) {
          lines.push(`- **Images:** ${issue.images.slice(0, 3).join(', ')}${issue.images.length > 3 ? '...' : ''}`);
        }
        if (issue.recommendation) {
          lines.push(`- ** Recommendation:** ${issue.recommendation}`);
        }
        lines.push('');
      });
    }

    // Resolved issues
    if (resolvedIssues && resolvedIssues.length > 0) {
      lines.push('####  Resolved Form Rendering Issues\n');
      resolvedIssues.forEach(issue => {
        lines.push(`- **${issue.type}**: ${issue.message}`);
      });
      lines.push('');
    }

    if (!after || (after.issues && after.issues.length === 0)) {
      lines.push(' No form rendering issues detected.\n');
    }

    return lines.join('\n');
  }

  /**
   * Build form CSS section
   */
  buildFormCSSSection(formCSS) {
    const lines = ['###  Form CSS Analysis\n'];

    const { after, newIssues } = formCSS;

    if (after) {
      lines.push(`**Files Analyzed:** ${after.filesAnalyzed}\n`);
    }

    // Show only critical issues in detail, summarize warnings
    if (newIssues && newIssues.length > 0) {
      const criticalIssues = newIssues.filter(i => i.severity === 'error');
      const warningIssues = newIssues.filter(i => i.severity === 'warning');
      
      // Critical issues - show details
      if (criticalIssues.length > 0) {
        lines.push('** Critical Issues:**\n');
        criticalIssues.forEach(issue => {
          lines.push(`- **${issue.file}** - ${issue.type}`);
        });
        lines.push('');
      }

      // Warnings - just count by type
      if (warningIssues.length > 0) {
        lines.push('** Warnings:**');
        const bgImages = warningIssues.filter(i => i.type === 'css-background-image').length;
        if (bgImages > 0) {
          lines.push(`- ${bgImages} CSS background-image(s) (use Image component instead)`);
        }
        lines.push(`- ${warningIssues.length} total warning(s)\n`);
      }
    }

    if (!newIssues || newIssues.length === 0) {
      lines.push(' No CSS issues detected.\n');
    }

    return lines.join('\n');
  }

  /**
   * Build custom functions section
   */
  buildCustomFunctionsSection(customFunctions) {
    const lines = ['###  Custom Functions Analysis\n'];

    const { before, after, newIssues, resolvedIssues } = customFunctions;

    if (after && after.functionsAnalyzed > 0) {
      lines.push(`**Custom Functions Analyzed:** ${after.functionsAnalyzed}\n`);
    }

    // Show all violations in current state
    if (newIssues && newIssues.length > 0) {
      lines.push('####  Violations Detected\n');
      
      const domAccessIssues = newIssues.filter(i => i.type === 'dom-access-in-custom-function');
      const httpRequestIssues = newIssues.filter(i => i.type === 'http-request-in-custom-function');

      if (httpRequestIssues.length > 0) {
        lines.push(`** ${httpRequestIssues.length} HTTP Request(s) in Custom Functions:**\n`);
        httpRequestIssues.forEach(issue => {
          lines.push(`- \`${issue.functionName}\` in \`${issue.file}\``);
          lines.push(`  - ${issue.recommendation}`);
        });
        lines.push('');
      }

      if (domAccessIssues.length > 0) {
        lines.push(`** ${domAccessIssues.length} DOM Access(es) in Custom Functions:**\n`);
        domAccessIssues.forEach(issue => {
          lines.push(`- \`${issue.functionName}\` in \`${issue.file}\``);
          lines.push(`  - ${issue.recommendation}`);
        });
        lines.push('');
      }
    }

    // Show resolved violations
    if (resolvedIssues && resolvedIssues.length > 0) {
      lines.push(` **Resolved:** ${resolvedIssues.length} custom function violation(s) fixed\n`);
    }

    if ((!newIssues || newIssues.length === 0) && (!resolvedIssues || resolvedIssues.length === 0)) {
      lines.push(' No custom function violations detected.\n');
    }

    return lines.join('\n');
  }

  /**
   * Build summary section
   */
  buildFormSummarySection(results) {
    const lines = ['\n---\n###  Overall Assessment\n'];

    // Calculate overall impact
    const impact = this.calculateFormImpact(results);
    
    lines.push(`**Performance Impact:** ${impact.rating} ${impact.emoji}\n`);
    
    if (impact.critical.length > 0) {
      lines.push('** Critical Issues:**');
      impact.critical.forEach(c => lines.push(`- ${c}`));
      lines.push('');
    }

    if (impact.warnings.length > 0) {
      lines.push('** Warnings:**');
      impact.warnings.forEach(w => lines.push(`- ${w}`));
      lines.push('');
    }

    if (impact.positives.length > 0) {
      lines.push('** Improvements:**');
      impact.positives.forEach(p => lines.push(`- ${p}`));
      lines.push('');
    }

    if (impact.recommendations.length > 0) {
      lines.push('** Recommendations:**');
      impact.recommendations.forEach(r => lines.push(`- ${r}`));
    }

    return lines.join('\n');
  }

  /**
   * Calculate overall form performance impact
   */
  calculateFormImpact(results) {
    const impact = {
      rating: 'Neutral',
      emoji: '',
      critical: [],
      warnings: [],
      positives: [],
      recommendations: [],
    };

    let score = 0;

    // Form structure impact
    if (results.formStructure && results.formStructure.delta) {
      const { delta, newIssues, resolvedIssues } = results.formStructure;

      if (resolvedIssues && resolvedIssues.length > 0) {
        impact.positives.push(`Resolved ${resolvedIssues.length} form structure issue(s)`);
        score += resolvedIssues.length * 5;
      }
      
      if (newIssues && newIssues.length > 0) {
        impact.warnings.push(`${newIssues.length} new form structure issue(s)`);
        score -= newIssues.length * 5;
      }
    }

    // API calls in initialize
    if (results.formEvents) {
      const { newIssues, resolvedIssues } = results.formEvents;
      
      if (newIssues && newIssues.length > 0) {
        impact.critical.push(`${newIssues.length} API call(s) in initialize events - blocks form rendering`);
        impact.recommendations.push('Move API calls from initialize to custom events or lazy load after render');
        score -= newIssues.length * 30;
      }

      if (resolvedIssues && resolvedIssues.length > 0) {
        impact.positives.push(`Moved ${resolvedIssues.length} API call(s) out of initialize events`);
        score += resolvedIssues.length * 30;
      }
    }

    // Hidden fields
    if (results.hiddenFields) {
      const { delta, newIssues, resolvedIssues } = results.hiddenFields;
      
      if (newIssues && newIssues.length > 0) {
        impact.warnings.push(`${newIssues.length} unnecessary hidden field(s) bloating DOM`);
        impact.recommendations.push('Remove hidden fields that are never shown - use Form variables instead');
        score -= newIssues.length * 10;
      }

      if (resolvedIssues && resolvedIssues.length > 0) {
        impact.positives.push(`Removed ${resolvedIssues.length} unnecessary hidden field(s)`);
        score += resolvedIssues.length * 10;
      }
    }

    // Rule cycles and slow rules
    if (results.ruleCycles && !results.ruleCycles.after?.error) {
      const { newCycles, resolvedCycles, after, slowRuleCount } = results.ruleCycles;
      
      if (newCycles && newCycles.length > 0) {
        impact.critical.push(`${newCycles.length} circular dependenc${newCycles.length > 1 ? 'ies' : 'y'} - can cause infinite loops`);
        impact.recommendations.push('Break circular dependencies immediately - these cause severe performance issues');
        score -= newCycles.length * 50;
      }

      if (resolvedCycles && resolvedCycles.length > 0) {
        impact.positives.push(`Resolved ${resolvedCycles.length} circular dependenc${resolvedCycles.length > 1 ? 'ies' : 'y'}`);
        score += resolvedCycles.length * 50;
      }

      if (after && after.cycles > 0 && !newCycles?.length) {
        impact.warnings.push(`${after.cycles} existing circular dependenc${after.cycles > 1 ? 'ies' : 'y'} still present`);
      }
      
      // Slow rules (CRITICAL - blocks interactions)
      if (slowRuleCount > 0) {
        impact.critical.push(`${slowRuleCount} slow rule(s) detected (> 50ms execution) - blocks form interactions`);
        impact.recommendations.push('Optimize slow rules: reduce computations, or defer this rule until after form renders');
        score -= slowRuleCount * 20;
      }
    }

    // Form HTML rendering
    if (results.formHTML && !results.formHTML.error) {
      const { newIssues, resolvedIssues, delta } = results.formHTML;
      
      if (newIssues && newIssues.length > 0) {
        const criticalHTML = newIssues.filter(i => i.severity === 'error');
        const warningHTML = newIssues.filter(i => i.severity === 'warning');
        
        if (criticalHTML.length > 0) {
          impact.critical.push(`${criticalHTML.length} critical form rendering issue(s)`);
          score -= criticalHTML.length * 15;
        }
        
        if (warningHTML.length > 0) {
          impact.warnings.push(`${warningHTML.length} form rendering warning(s)`);
          score -= warningHTML.length * 5;
        }
        
        // Specific issues
        const nonLazyImages = newIssues.find(i => i.type === 'images-not-lazy-loaded');
        if (nonLazyImages) {
          impact.warnings.push(`${nonLazyImages.count} image(s) in form without lazy loading`);
          impact.recommendations.push('Add loading="lazy" to form images to improve rendering performance');
        }
        
        const blockingScripts = newIssues.find(i => i.type === 'blocking-scripts-in-form');
        if (blockingScripts) {
          impact.critical.push(`${blockingScripts.count} blocking script(s) in form`);
          impact.recommendations.push('Add async/defer to scripts or load after form renders');
        }
      }

      if (resolvedIssues && resolvedIssues.length > 0) {
        impact.positives.push(`Resolved ${resolvedIssues.length} form rendering issue(s)`);
        score += resolvedIssues.length * 10;
      }
    }

    // Form CSS issues
    if (results.formCSS && results.formCSS.after) {
      const { newIssues, after } = results.formCSS;
      
      if (newIssues && newIssues.length > 0) {
        const criticalCSS = newIssues.filter(i => i.severity === 'error');
        const warningCSS = newIssues.filter(i => i.severity === 'warning');
        
        if (criticalCSS.length > 0) {
          impact.critical.push(`${criticalCSS.length} critical CSS issue(s)`);
          score -= criticalCSS.length * 10;
        }
        
        if (warningCSS.length > 0) {
          impact.warnings.push(`${warningCSS.length} CSS warning(s)`);
          score -= warningCSS.length * 3;
        }
        
        // Specific CSS issues
        const backgroundImages = newIssues.filter(i => i.type === 'css-background-image');
        if (backgroundImages.length > 0) {
          impact.warnings.push(`${backgroundImages.length} CSS background-image(s) should use Image component`);
          impact.recommendations.push('Replace CSS background images with <Image> component for lazy loading and optimization');
        }
        
        const blockingImports = newIssues.filter(i => i.type === 'css-import-blocking');
        if (blockingImports.length > 0) {
          impact.critical.push(`${blockingImports.length} @import statement(s) blocking rendering`);
          impact.recommendations.push('Replace @import with <link> tags or bundle CSS');
        }
      }

      // Summary stats
      if (after.summary) {
        if (after.summary.backgroundImages > 0) {
          // Already handled above
        }
        if (after.summary.importantRules > 50) {
          impact.warnings.push(`Excessive !important usage (${after.summary.importantRules} times)`);
        }
      }
    }

    // Custom Functions violations
    if (results.customFunctions && !results.customFunctions.error) {
      const { newIssues, resolvedIssues } = results.customFunctions;
      
      if (newIssues && newIssues.length > 0) {
        const domAccessIssues = newIssues.filter(i => i.type === 'dom-access-in-custom-function');
        const httpRequestIssues = newIssues.filter(i => i.type === 'http-request-in-custom-function');
        
        if (domAccessIssues.length > 0) {
          impact.critical.push(`${domAccessIssues.length} custom function(s) accessing DOM directly`);
          impact.recommendations.push('Remove DOM access from custom functions - use form data model instead');
          score -= domAccessIssues.length * 40;
        }
        
        if (httpRequestIssues.length > 0) {
          impact.critical.push(`${httpRequestIssues.length} custom function(s) making HTTP requests`);
          impact.recommendations.push('Use request() API tool instead of direct HTTP calls in custom functions');
          score -= httpRequestIssues.length * 30;
        }
      }

      if (resolvedIssues && resolvedIssues.length > 0) {
        impact.positives.push(`Fixed ${resolvedIssues.length} custom function violation(s)`);
        score += resolvedIssues.length * 35;
      }
    }

    // Determine overall rating
    if (score > 20) {
      impact.rating = 'Positive';
      impact.emoji = '';
    } else if (score < -20) {
      impact.rating = 'Negative';
      impact.emoji = '';
    } else {
      impact.rating = 'Neutral';
      impact.emoji = '';
    }

    // Add critical marker if severe issues exist
    if (impact.critical.length > 0) {
      impact.rating = 'Critical Issues Detected';
      impact.emoji = '';
    }

    return impact;
  }

  /**
   * Format delta with sign
   */
  formatDelta(value) {
    if (value === 0) return '0';
    const sign = value > 0 ? '+' : '';
    const emoji = value > 0 ? '' : value < 0 ? '' : '';
    return `${sign}${value} ${emoji}`;
  }

  /**
   * Get emoji for severity
   */
  getSeverityEmoji(severity) {
    const map = {
      error: '',
      warning: '',
      info: '',
    };
    return map[severity] || '';
  }

  /**
   * Post comment to PR
   */
  async postComment(body) {
    await this.octokit.rest.issues.createComment({
      owner: this.owner,
      repo: this.repo,
      issue_number: this.prNumber,
      body,
    });
  }

  /**
   * Count critical issues
   */
  countCriticalIssues(results) {
    let count = 0;
    if (results.formEvents?.after?.apiCallsInInitialize?.length) {
      count += results.formEvents.after.apiCallsInInitialize.length;
    }
    if (results.customFunctions?.after?.httpRequestCount) {
      count += results.customFunctions.after.httpRequestCount;
    }
    if (results.formCSS?.after?.issues?.filter(i => i.severity === 'error').length) {
      count += results.formCSS.after.issues.filter(i => i.severity === 'error').length;
    }
    if (results.ruleCycles?.after?.cycles) {
      count += results.ruleCycles.after.cycles;
    }
    return count;
  }

  /**
   * Count warnings
   */
  countWarnings(results) {
    let count = 0;
    if (results.hiddenFields?.after?.unnecessaryHiddenFields) {
      count += results.hiddenFields.after.unnecessaryHiddenFields;
    }
    if (results.formCSS?.after?.issues?.filter(i => i.severity === 'warning').length) {
      count += results.formCSS.after.issues.filter(i => i.severity === 'warning').length;
    }
    if (results.formHTML?.after?.issues?.filter(i => i.severity === 'warning').length) {
      count += results.formHTML.after.issues.filter(i => i.severity === 'warning').length;
    }
    return count;
  }

  /**
   * Get load status string
   */
  getLoadStatus(urls) {
    const after = urls.afterData?.performanceMetrics;
    if (!after) return 'Unknown';
    if (!after.formRendered) return `Failed (${Math.round(after.loadTime/1000)}s timeout)`;
    if (after.loadTime < 2000) return `${after.loadTime}ms (Fast)`;
    if (after.loadTime < 3000) return `${after.loadTime}ms (Good)`;
    return `${after.loadTime}ms (Slow)`;
  }

  /**
   * Build top priority actions section
   */
  buildTopActionsSection(results, urls) {
    const actions = [];
    let actionNum = 1;

    // API calls in initialize
    const apiCalls = results.formEvents?.after?.apiCallsInInitialize || [];
    if (apiCalls.length > 0) {
      actions.push(`${actionNum}. **Fix API Blocking** â†’ ${apiCalls.length} initialize call(s) blocking render [See full report]`);
      actionNum++;
    }

    // HTTP in custom functions
    const httpCount = results.customFunctions?.after?.httpRequestCount || 0;
    if (httpCount > 0) {
      actions.push(`${actionNum}. **Fix HTTP Calls** â†’ ${httpCount} function(s) bypassing form API [See full report]`);
      actionNum++;
    }

    // Form load failure
    if (urls.afterData?.performanceMetrics && !urls.afterData.performanceMetrics.formRendered) {
      actions.push(`${actionNum}. **Investigate Timeout** â†’ Form failed to load in 15s [Check logs]`);
      actionNum++;
    }

    // CSS critical
    const cssCritical = results.formCSS?.after?.issues?.filter(i => i.severity === 'error') || [];
    if (cssCritical.length > 0 && actionNum <= 5) {
      actions.push(`${actionNum}. **Fix CSS Critical** â†’ ${cssCritical.length} issue(s) blocking render [See full report]`);
      actionNum++;
    }

    // Rule cycles
    if (results.ruleCycles?.after?.cycles > 0 && actionNum <= 5) {
      actions.push(`${actionNum}. **Fix Rule Cycles** â†’ ${results.ruleCycles.after.cycles} circular dependenc${results.ruleCycles.after.cycles > 1 ? 'ies' : 'y'} detected [See full report]`);
      actionNum++;
    }

    return actions.length > 0 ? actions.join('\n') + '\n' : '';
  }

  /**
   * Build quick stats section
   */
  buildQuickStatsSection(results, urls) {
    const lines = ['### ðŸ“Š Quick Stats\n'];
    
    const components = results.formStructure?.after?.components?.total || 0;
    const rules = results.ruleCycles?.after?.totalRules || 0;
    const cycles = results.ruleCycles?.after?.cycles || 0;
    const hidden = results.hiddenFields?.after?.unnecessaryHiddenFields || 0;
    const loadTime = urls.afterData?.performanceMetrics?.formRendered 
      ? `${urls.afterData.performanceMetrics.loadTime}ms`
      : 'Failed';

    lines.push(`- **Components:** ${components} | **Rules:** ${rules} (${cycles} cycles)`);
    lines.push(`- **Form Load:** ${loadTime} | **Hidden Fields:** ${hidden} unnecessary`);
    lines.push(`- **CSS Files:** ${results.formCSS?.after?.filesAnalyzed || 0} analyzed | **Custom Functions:** ${results.customFunctions?.after?.analyzed || 0} analyzed`);
    
    return lines.join('\n');
  }
}

