/**
 * Form-specific report generation for PR comments
 */
export class FormPRReporter {
  constructor(octokit, owner, repo, prNumber) {
    this.octokit = octokit;
    this.owner = owner;
    this.repo = repo;
    this.prNumber = prNumber;
  }

  /**
   * Generate and post the performance report
   */
  async generateReport(results, urls) {
    const report = this.buildMarkdownReport(results, urls);
    
    try {
      await this.postComment(report);
      console.log('Performance report posted successfully');
    } catch (error) {
      console.error('Error posting comment:', error.message);
      throw error;
    }
  }

  /**
   * Build the markdown report
   */
  buildMarkdownReport(results, urls) {
    const sections = [];

    // Header
    sections.push('## ðŸŽ¯ Form Performance Analysis Report\n');
    sections.push(`> **Automated analysis of Adaptive Form performance**\n`);
    sections.push(`**Analysis Time:** ${new Date().toISOString()}`);
    sections.push(`**Before:** \`${urls.before}\``);
    sections.push(`**After:** \`${urls.after}\`\n`);

    sections.push('---\n');

    // Form Structure Analysis
    if (results.formStructure && !results.formStructure.error) {
      sections.push(this.buildFormStructureSection(results.formStructure));
    }

    // Form Events Analysis (API calls in initialize)
    if (results.formEvents && !results.formEvents.error) {
      sections.push(this.buildFormEventsSection(results.formEvents));
    }

    // Hidden Fields Analysis
    if (results.hiddenFields && !results.hiddenFields.error) {
      sections.push(this.buildHiddenFieldsSection(results.hiddenFields));
    }

    // Rule Cycles Analysis
    if (results.ruleCycles && !results.ruleCycles.error) {
      sections.push(this.buildRuleCyclesSection(results.ruleCycles));
    }

    // Form HTML Analysis
    if (results.formHTML && !results.formHTML.error) {
      sections.push(this.buildFormHTMLSection(results.formHTML));
    }

    // Form CSS Analysis
    if (results.formCSS && results.formCSS.after) {
      sections.push(this.buildFormCSSSection(results.formCSS));
    }

    // Custom Functions Analysis
    if (results.customFunctions && !results.customFunctions.error) {
      sections.push(this.buildCustomFunctionsSection(results.customFunctions));
    }

    // Summary
    sections.push(this.buildFormSummarySection(results));

    sections.push('\n---');
    sections.push('*Generated by Performance Bot* ðŸ¤–');

    return sections.join('\n');
  }

  /**
   * Build form structure section
   */
  buildFormStructureSection(formAnalysis) {
    const lines = ['### ðŸ“ Form Structure\n'];

    if (formAnalysis.before && formAnalysis.after) {
      const { delta, newIssues, resolvedIssues } = formAnalysis;

      lines.push('| Metric | Before | After | Change |');
      lines.push('|--------|--------|-------|--------|');
      lines.push(`| Components | ${formAnalysis.before.components.total} | ${formAnalysis.after.components.total} | ${this.formatDelta(delta.components)} |`);
      lines.push(`| Event Handlers | ${formAnalysis.before.events.total} | ${formAnalysis.after.events.total} | ${this.formatDelta(delta.events)} |`);
      lines.push(`| Max Nesting Depth | ${formAnalysis.before.components.maxDepth} | ${formAnalysis.after.components.maxDepth} | ${this.formatDelta(delta.maxDepth)} |\n`);

      // New issues
      if (newIssues.length > 0) {
        lines.push('#### âš ï¸ New Issues\n');
        newIssues.forEach(issue => {
          lines.push(`- **${this.getSeverityEmoji(issue.severity)} ${issue.type}**: ${issue.message}`);
        });
        lines.push('');
      }

      // Resolved issues
      if (resolvedIssues.length > 0) {
        lines.push('#### âœ… Resolved Issues\n');
        resolvedIssues.forEach(issue => {
          lines.push(`- **${issue.type}**: ${issue.message}`);
        });
        lines.push('');
      }
    }

    return lines.join('\n');
  }

  /**
   * Build form events section (API calls in initialize)
   */
  buildFormEventsSection(formEvents) {
    const lines = ['### âš¡ Form Events Analysis\n'];

    const { newIssues, resolvedIssues, after } = formEvents;

    if (after && after.apiCallsInInitialize && after.apiCallsInInitialize.length > 0) {
      lines.push(`**API Calls in Initialize Events:** ${after.apiCallsInInitialize.length}\n`);
      
      after.apiCallsInInitialize.forEach(apiCall => {
        lines.push(`- ðŸš¨ **Field:** \`${apiCall.field}\``);
        lines.push(`  - **Path:** \`${apiCall.path}\``);
        lines.push(`  - **Type:** ${apiCall.apiCallType}`);
        lines.push(`  - **Expression:** \`${apiCall.expression.substring(0, 100)}${apiCall.expression.length > 100 ? '...' : ''}\``);
        lines.push('');
      });
    }

    // New issues
    if (newIssues && newIssues.length > 0) {
      lines.push('#### ðŸš¨ Critical: API Calls in Initialize Events\n');
      newIssues.forEach(issue => {
        lines.push(`**Field: \`${issue.field}\`**`);
        lines.push(`- **Issue:** ${issue.message}`);
        lines.push(`- **ðŸ’¡ Recommendation:** ${issue.recommendation}\n`);
      });
    }

    // Resolved issues
    if (resolvedIssues && resolvedIssues.length > 0) {
      lines.push('#### âœ… Fixed: API Calls Moved from Initialize\n');
      resolvedIssues.forEach(issue => {
        lines.push(`- Field \`${issue.field}\` - API call removed from initialize event`);
      });
      lines.push('');
    }

    if (!after || (after.apiCallsInInitialize && after.apiCallsInInitialize.length === 0)) {
      lines.push('âœ… No API calls found in initialize events.\n');
    }

    return lines.join('\n');
  }

  /**
   * Build hidden fields section
   */
  buildHiddenFieldsSection(hiddenFields) {
    const lines = ['### ðŸ‘ï¸ Hidden Fields Analysis\n'];

    const { delta, newIssues, resolvedIssues, after } = hiddenFields;

    if (after) {
      lines.push(`**Total Hidden Fields:** ${after.totalHiddenFields}`);
      lines.push(`**Unnecessary Hidden Fields:** ${after.unnecessaryHiddenFields}\n`);

      if (delta && (delta.hiddenFields !== 0 || delta.unnecessaryFields !== 0)) {
        lines.push('**Changes:**');
        if (delta.hiddenFields !== 0) {
          lines.push(`- Hidden fields: ${this.formatDelta(delta.hiddenFields)}`);
        }
        if (delta.unnecessaryFields !== 0) {
          lines.push(`- Unnecessary fields: ${this.formatDelta(delta.unnecessaryFields)}`);
        }
        lines.push('');
      }
    }

    // New issues
    if (newIssues && newIssues.length > 0) {
      lines.push('#### âš ï¸ Unnecessary Hidden Fields Detected\n');
      newIssues.forEach(issue => {
        lines.push(`**Field: \`${issue.field}\`**`);
        lines.push(`- **Issue:** ${issue.message}`);
        lines.push(`- **ðŸ’¡ Recommendation:** ${issue.recommendation}\n`);
      });
    }

    // Resolved issues
    if (resolvedIssues && resolvedIssues.length > 0) {
      lines.push('#### âœ… Removed Unnecessary Hidden Fields\n');
      resolvedIssues.forEach(issue => {
        lines.push(`- Field \`${issue.field}\` removed or made properly visible`);
      });
      lines.push('');
    }

    if (!after || after.unnecessaryHiddenFields === 0) {
      lines.push('âœ… No unnecessary hidden fields detected.\n');
    }

    return lines.join('\n');
  }

  /**
   * Build rule cycles section
   */
  buildRuleCyclesSection(ruleCycles) {
    const lines = ['### ðŸ”„ Rule Dependency Cycles\n'];

    const { newCycles, resolvedCycles, after } = ruleCycles;

    if (after && !after.error) {
      lines.push(`**Total Rules:** ${after.totalRules || 0}`);
      lines.push(`**Fields with Rules:** ${after.fieldsWithRules || 0}`);
      lines.push(`**Circular Dependencies:** ${after.cycles || 0}\n`);

      // Show cycle details
      if (after.cycleDetails && after.cycleDetails.length > 0) {
        lines.push('#### ðŸš¨ Critical: Circular Dependencies Found\n');
        
        after.cycleDetails.forEach((cycle, index) => {
          lines.push(`**Cycle ${index + 1}:** \`${cycle.fields.join(' â†’ ')}\``);
          lines.push(`- **Fields involved:** ${cycle.fields.filter((f, i, arr) => arr.indexOf(f) === i).join(', ')}`);
          lines.push(`- **ðŸ’¡ Recommendation:** Break this circular dependency by removing or modifying one of the rules. This can cause infinite loops and severely impact performance.\n`);
        });
      }
    }

    if (after && after.error) {
      lines.push(`âš ï¸ Error analyzing rule cycles: ${after.error}\n`);
    }

    // New cycles
    if (newCycles && newCycles.length > 0) {
      lines.push('#### ðŸš¨ New Circular Dependencies Introduced\n');
      newCycles.forEach(cycle => {
        lines.push(`- \`${cycle.fields.join(' â†’ ')}\``);
      });
      lines.push('');
    }

    // Resolved cycles
    if (resolvedCycles && resolvedCycles.length > 0) {
      lines.push('#### âœ… Resolved Circular Dependencies\n');
      resolvedCycles.forEach(cycle => {
        lines.push(`- \`${cycle.fields.join(' â†’ ')}\``);
      });
      lines.push('');
    }

    if (!after || (!after.error && (after.cycles === 0 || !after.cycles))) {
      lines.push('âœ… No circular dependencies detected.\n');
    }

    return lines.join('\n');
  }

  /**
   * Build form HTML section
   */
  buildFormHTMLSection(formHTML) {
    const lines = ['### ðŸŽ¨ Form HTML & Rendering Performance\n'];

    const { newIssues, resolvedIssues, after, delta } = formHTML;

    if (after) {
      lines.push('**Form Content:**');
      lines.push(`- Images: ${after.images.total} (${after.images.nonLazyLoaded} without lazy loading)`);
      lines.push(`- DOM Elements: ${after.rendering.totalElements}`);
      lines.push(`- Blocking Scripts: ${after.scripts.blocking}`);
      lines.push(`- Hidden Elements: ${after.rendering.hiddenElements}\n`);

      if (delta) {
        const hasChanges = delta.images !== 0 || delta.nonLazyImages !== 0 || 
                          delta.totalElements !== 0 || delta.blockingScripts !== 0;
        
        if (hasChanges) {
          lines.push('**Changes:**');
          if (delta.images !== 0) {
            lines.push(`- Images: ${this.formatDelta(delta.images)}`);
          }
          if (delta.nonLazyImages !== 0) {
            lines.push(`- Non-lazy images: ${this.formatDelta(delta.nonLazyImages)}`);
          }
          if (delta.totalElements !== 0) {
            lines.push(`- DOM elements: ${this.formatDelta(delta.totalElements)}`);
          }
          if (delta.blockingScripts !== 0) {
            lines.push(`- Blocking scripts: ${this.formatDelta(delta.blockingScripts)}`);
          }
          lines.push('');
        }
      }
    }

    // New issues
    if (newIssues && newIssues.length > 0) {
      lines.push('#### âš ï¸ Form Rendering Issues\n');
      newIssues.forEach(issue => {
        lines.push(`**${this.getSeverityEmoji(issue.severity)} ${issue.type}**`);
        lines.push(`- **Issue:** ${issue.message}`);
        if (issue.images && issue.images.length > 0) {
          lines.push(`- **Images:** ${issue.images.slice(0, 3).join(', ')}${issue.images.length > 3 ? '...' : ''}`);
        }
        if (issue.recommendation) {
          lines.push(`- **ðŸ’¡ Recommendation:** ${issue.recommendation}`);
        }
        lines.push('');
      });
    }

    // Resolved issues
    if (resolvedIssues && resolvedIssues.length > 0) {
      lines.push('#### âœ… Resolved Form Rendering Issues\n');
      resolvedIssues.forEach(issue => {
        lines.push(`- **${issue.type}**: ${issue.message}`);
      });
      lines.push('');
    }

    if (!after || (after.issues && after.issues.length === 0)) {
      lines.push('âœ… No form rendering issues detected.\n');
    }

    return lines.join('\n');
  }

  /**
   * Build form CSS section
   */
  buildFormCSSSection(formCSS) {
    const lines = ['### ðŸŽ¨ Form CSS Analysis\n'];

    const { after, newIssues } = formCSS;

    if (after) {
      lines.push(`**Files Analyzed:** ${after.filesAnalyzed}`);
      
      if (after.summary) {
        const { backgroundImages, importantRules, inlineDataURIs, deepSelectors, duplicateSelectors } = after.summary;
        
        if (backgroundImages > 0 || importantRules > 0 || inlineDataURIs > 0 || deepSelectors > 0 || duplicateSelectors > 0) {
          lines.push('\n**Issues Found:**');
          if (backgroundImages > 0) {
            lines.push(`- CSS background-image: ${backgroundImages} (should use Image component)`);
          }
          if (inlineDataURIs > 0) {
            lines.push(`- Inline data URIs: ${inlineDataURIs}`);
          }
          if (importantRules > 0) {
            lines.push(`- !important usage: ${importantRules} times`);
          }
          if (deepSelectors > 0) {
            lines.push(`- Deep selectors: ${deepSelectors}`);
          }
          if (duplicateSelectors > 0) {
            lines.push(`- Duplicate selectors: ${duplicateSelectors}`);
          }
          lines.push('');
        }
      }
    }

    // Show issues
    if (newIssues && newIssues.length > 0) {
      lines.push('#### ðŸ” CSS Issues Detected\n');
      
      // Group by severity
      const criticalIssues = newIssues.filter(i => i.severity === 'error').slice(0, 3);
      const warnings = newIssues.filter(i => i.severity === 'warning').slice(0, 5);
      const info = newIssues.filter(i => i.severity === 'info').slice(0, 3);

      if (criticalIssues.length > 0) {
        lines.push('**Critical:**\n');
        criticalIssues.forEach(issue => {
          lines.push(`ðŸš¨ **${issue.file}:${issue.line || '?'}** - ${issue.type}`);
          lines.push(`- ${issue.message}`);
          if (issue.recommendation) {
            lines.push(`- ðŸ’¡ *${issue.recommendation}*`);
          }
          lines.push('');
        });
      }

      if (warnings.length > 0) {
        lines.push('**Warnings:**\n');
        warnings.forEach(issue => {
          lines.push(`âš ï¸ **${issue.file}:${issue.line || '?'}** - ${issue.type}`);
          lines.push(`- ${issue.message}`);
          if (issue.imageUrl) {
            lines.push(`- Image: \`${issue.imageUrl}\``);
          }
          if (issue.recommendation) {
            lines.push(`- ðŸ’¡ *${issue.recommendation}*`);
          }
          lines.push('');
        });
      }

      if (info.length > 0 && criticalIssues.length === 0 && warnings.length < 3) {
        lines.push('**Info:**\n');
        info.forEach(issue => {
          lines.push(`â„¹ï¸ **${issue.file}** - ${issue.type}`);
          lines.push(`- ${issue.message}`);
          if (issue.recommendation) {
            lines.push(`- ðŸ’¡ *${issue.recommendation}*`);
          }
          lines.push('');
        });
      }

      const remaining = newIssues.length - criticalIssues.length - warnings.length - info.length;
      if (remaining > 0) {
        lines.push(`*...and ${remaining} more CSS issue(s)*\n`);
      }
    }

    if (!newIssues || newIssues.length === 0) {
      lines.push('âœ… No CSS issues detected.\n');
    }

    return lines.join('\n');
  }

  /**
   * Build custom functions section
   */
  buildCustomFunctionsSection(customFunctions) {
    const lines = ['### âš¡ Custom Functions Analysis\n'];

    const { before, after, newIssues, resolvedIssues } = customFunctions;

    if (after) {
      lines.push(`**Functions Found:** ${after.functionsFound}`);
      lines.push(`**Functions Analyzed:** ${after.functionsAnalyzed}`);
      
      if (after.functionNames && after.functionNames.length > 0) {
        lines.push(`**Function Names:** \`${after.functionNames.join('`, `')}\``);
      }
      lines.push('');
    }

    // Show new violations
    if (newIssues && newIssues.length > 0) {
      lines.push('#### ðŸš¨ Custom Function Violations\n');
      
      const domAccessIssues = newIssues.filter(i => i.type === 'dom-access-in-custom-function');
      const httpRequestIssues = newIssues.filter(i => i.type === 'http-request-in-custom-function');

      if (domAccessIssues.length > 0) {
        lines.push('**ðŸš¨ DOM Access Detected:**\n');
        domAccessIssues.forEach(issue => {
          lines.push(`**Function:** \`${issue.functionName}\` (${issue.file}:${issue.line})`);
          lines.push(`- ${issue.message}`);
          lines.push(`- **Impact:** ${issue.cwvImpact}`);
          if (issue.details && issue.details.length > 0) {
            const accessTypes = issue.details.map(d => d.type).join(', ');
            lines.push(`- **Accesses:** ${accessTypes}`);
          }
          lines.push(`- ðŸ’¡ *${issue.recommendation}*`);
          lines.push('');
        });
      }

      if (httpRequestIssues.length > 0) {
        lines.push('**ðŸš¨ HTTP Requests Detected:**\n');
        httpRequestIssues.forEach(issue => {
          lines.push(`**Function:** \`${issue.functionName}\` (${issue.file}:${issue.line})`);
          lines.push(`- ${issue.message}`);
          lines.push(`- **Impact:** ${issue.cwvImpact}`);
          if (issue.details && issue.details.length > 0) {
            const requestTypes = issue.details.map(d => d.type).join(', ');
            lines.push(`- **Request Types:** ${requestTypes}`);
          }
          lines.push(`- ðŸ’¡ *${issue.recommendation}*`);
          lines.push('');
        });
      }
    }

    // Show resolved violations
    if (resolvedIssues && resolvedIssues.length > 0) {
      lines.push(`âœ… **Resolved:** ${resolvedIssues.length} custom function violation(s) fixed\n`);
    }

    if ((!newIssues || newIssues.length === 0) && (!resolvedIssues || resolvedIssues.length === 0)) {
      lines.push('âœ… No custom function violations detected.\n');
    }

    return lines.join('\n');
  }

  /**
   * Build summary section
   */
  buildFormSummarySection(results) {
    const lines = ['\n---\n### ðŸ“Š Overall Assessment\n'];

    // Calculate overall impact
    const impact = this.calculateFormImpact(results);
    
    lines.push(`**Performance Impact:** ${impact.rating} ${impact.emoji}\n`);
    
    if (impact.critical.length > 0) {
      lines.push('**ðŸš¨ Critical Issues:**');
      impact.critical.forEach(c => lines.push(`- ${c}`));
      lines.push('');
    }

    if (impact.warnings.length > 0) {
      lines.push('**âš ï¸ Warnings:**');
      impact.warnings.forEach(w => lines.push(`- ${w}`));
      lines.push('');
    }

    if (impact.positives.length > 0) {
      lines.push('**âœ… Improvements:**');
      impact.positives.forEach(p => lines.push(`- ${p}`));
      lines.push('');
    }

    if (impact.recommendations.length > 0) {
      lines.push('**ðŸ’¡ Recommendations:**');
      impact.recommendations.forEach(r => lines.push(`- ${r}`));
    }

    return lines.join('\n');
  }

  /**
   * Calculate overall form performance impact
   */
  calculateFormImpact(results) {
    const impact = {
      rating: 'Neutral',
      emoji: 'âž–',
      critical: [],
      warnings: [],
      positives: [],
      recommendations: [],
    };

    let score = 0;

    // Form structure impact
    if (results.formStructure && results.formStructure.delta) {
      const { delta, newIssues, resolvedIssues } = results.formStructure;

      if (resolvedIssues && resolvedIssues.length > 0) {
        impact.positives.push(`Resolved ${resolvedIssues.length} form structure issue(s)`);
        score += resolvedIssues.length * 5;
      }
      
      if (newIssues && newIssues.length > 0) {
        impact.warnings.push(`${newIssues.length} new form structure issue(s)`);
        score -= newIssues.length * 5;
      }
    }

    // API calls in initialize
    if (results.formEvents) {
      const { newIssues, resolvedIssues } = results.formEvents;
      
      if (newIssues && newIssues.length > 0) {
        impact.critical.push(`${newIssues.length} API call(s) in initialize events - blocks form rendering`);
        impact.recommendations.push('Move API calls from initialize to custom events or lazy load after render');
        score -= newIssues.length * 30;
      }

      if (resolvedIssues && resolvedIssues.length > 0) {
        impact.positives.push(`Moved ${resolvedIssues.length} API call(s) out of initialize events`);
        score += resolvedIssues.length * 30;
      }
    }

    // Hidden fields
    if (results.hiddenFields) {
      const { delta, newIssues, resolvedIssues } = results.hiddenFields;
      
      if (newIssues && newIssues.length > 0) {
        impact.warnings.push(`${newIssues.length} unnecessary hidden field(s) bloating DOM`);
        impact.recommendations.push('Remove hidden fields that are never shown - use JavaScript variables instead');
        score -= newIssues.length * 10;
      }

      if (resolvedIssues && resolvedIssues.length > 0) {
        impact.positives.push(`Removed ${resolvedIssues.length} unnecessary hidden field(s)`);
        score += resolvedIssues.length * 10;
      }
    }

    // Rule cycles
    if (results.ruleCycles && !results.ruleCycles.after?.error) {
      const { newCycles, resolvedCycles, after } = results.ruleCycles;
      
      if (newCycles && newCycles.length > 0) {
        impact.critical.push(`${newCycles.length} circular dependenc${newCycles.length > 1 ? 'ies' : 'y'} introduced - can cause infinite loops`);
        impact.recommendations.push('Break circular dependencies immediately - these cause severe performance issues');
        score -= newCycles.length * 50;
      }

      if (resolvedCycles && resolvedCycles.length > 0) {
        impact.positives.push(`Resolved ${resolvedCycles.length} circular dependenc${resolvedCycles.length > 1 ? 'ies' : 'y'}`);
        score += resolvedCycles.length * 50;
      }

      if (after && after.cycles > 0 && !newCycles?.length) {
        impact.warnings.push(`${after.cycles} existing circular dependenc${after.cycles > 1 ? 'ies' : 'y'} still present`);
      }
    }

    // Form HTML rendering
    if (results.formHTML && !results.formHTML.error) {
      const { newIssues, resolvedIssues, delta } = results.formHTML;
      
      if (newIssues && newIssues.length > 0) {
        const criticalHTML = newIssues.filter(i => i.severity === 'error');
        const warningHTML = newIssues.filter(i => i.severity === 'warning');
        
        if (criticalHTML.length > 0) {
          impact.critical.push(`${criticalHTML.length} critical form rendering issue(s)`);
          score -= criticalHTML.length * 15;
        }
        
        if (warningHTML.length > 0) {
          impact.warnings.push(`${warningHTML.length} form rendering warning(s)`);
          score -= warningHTML.length * 5;
        }
        
        // Specific issues
        const nonLazyImages = newIssues.find(i => i.type === 'images-not-lazy-loaded');
        if (nonLazyImages) {
          impact.warnings.push(`${nonLazyImages.count} image(s) in form without lazy loading`);
          impact.recommendations.push('Add loading="lazy" to form images to improve rendering performance');
        }
        
        const blockingScripts = newIssues.find(i => i.type === 'blocking-scripts-in-form');
        if (blockingScripts) {
          impact.critical.push(`${blockingScripts.count} blocking script(s) in form`);
          impact.recommendations.push('Add async/defer to scripts or load after form renders');
        }
      }

      if (resolvedIssues && resolvedIssues.length > 0) {
        impact.positives.push(`Resolved ${resolvedIssues.length} form rendering issue(s)`);
        score += resolvedIssues.length * 10;
      }
    }

    // Form CSS issues
    if (results.formCSS && results.formCSS.after) {
      const { newIssues, after } = results.formCSS;
      
      if (newIssues && newIssues.length > 0) {
        const criticalCSS = newIssues.filter(i => i.severity === 'error');
        const warningCSS = newIssues.filter(i => i.severity === 'warning');
        
        if (criticalCSS.length > 0) {
          impact.critical.push(`${criticalCSS.length} critical CSS issue(s)`);
          score -= criticalCSS.length * 10;
        }
        
        if (warningCSS.length > 0) {
          impact.warnings.push(`${warningCSS.length} CSS warning(s)`);
          score -= warningCSS.length * 3;
        }
        
        // Specific CSS issues
        const backgroundImages = newIssues.filter(i => i.type === 'css-background-image');
        if (backgroundImages.length > 0) {
          impact.warnings.push(`${backgroundImages.length} CSS background-image(s) should use Image component`);
          impact.recommendations.push('Replace CSS background images with <Image> component for lazy loading and optimization');
        }
        
        const blockingImports = newIssues.filter(i => i.type === 'css-import-blocking');
        if (blockingImports.length > 0) {
          impact.critical.push(`${blockingImports.length} @import statement(s) blocking rendering`);
          impact.recommendations.push('Replace @import with <link> tags or bundle CSS');
        }
      }

      // Summary stats
      if (after.summary) {
        if (after.summary.backgroundImages > 0) {
          // Already handled above
        }
        if (after.summary.importantRules > 50) {
          impact.warnings.push(`Excessive !important usage (${after.summary.importantRules} times)`);
        }
      }
    }

    // Custom Functions violations
    if (results.customFunctions && !results.customFunctions.error) {
      const { newIssues, resolvedIssues } = results.customFunctions;
      
      if (newIssues && newIssues.length > 0) {
        const domAccessIssues = newIssues.filter(i => i.type === 'dom-access-in-custom-function');
        const httpRequestIssues = newIssues.filter(i => i.type === 'http-request-in-custom-function');
        
        if (domAccessIssues.length > 0) {
          impact.critical.push(`${domAccessIssues.length} custom function(s) accessing DOM directly`);
          impact.recommendations.push('Remove DOM access from custom functions - use form data model instead');
          score -= domAccessIssues.length * 40;
        }
        
        if (httpRequestIssues.length > 0) {
          impact.critical.push(`${httpRequestIssues.length} custom function(s) making HTTP requests`);
          impact.recommendations.push('Use request() API tool instead of direct HTTP calls in custom functions');
          score -= httpRequestIssues.length * 30;
        }
      }

      if (resolvedIssues && resolvedIssues.length > 0) {
        impact.positives.push(`Fixed ${resolvedIssues.length} custom function violation(s)`);
        score += resolvedIssues.length * 35;
      }
    }

    // Determine overall rating
    if (score > 20) {
      impact.rating = 'Positive';
      impact.emoji = 'âœ…';
    } else if (score < -20) {
      impact.rating = 'Negative';
      impact.emoji = 'âŒ';
    } else {
      impact.rating = 'Neutral';
      impact.emoji = 'âž–';
    }

    // Add critical marker if severe issues exist
    if (impact.critical.length > 0) {
      impact.rating = 'Critical Issues Detected';
      impact.emoji = 'ðŸš¨';
    }

    return impact;
  }

  /**
   * Format delta with sign
   */
  formatDelta(value) {
    if (value === 0) return '0';
    const sign = value > 0 ? '+' : '';
    const emoji = value > 0 ? 'ðŸ“ˆ' : value < 0 ? 'ðŸ“‰' : '';
    return `${sign}${value} ${emoji}`;
  }

  /**
   * Get emoji for severity
   */
  getSeverityEmoji(severity) {
    const map = {
      error: 'ðŸš¨',
      warning: 'âš ï¸',
      info: 'â„¹ï¸',
    };
    return map[severity] || 'â„¹ï¸';
  }

  /**
   * Post comment to PR
   */
  async postComment(body) {
    await this.octokit.rest.issues.createComment({
      owner: this.owner,
      repo: this.repo,
      issue_number: this.prNumber,
      body,
    });
  }
}

