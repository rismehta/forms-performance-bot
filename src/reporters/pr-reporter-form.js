/**
 * Form-specific report generation for PR comments
 */
export class FormPRReporter {
  constructor(octokit, owner, repo, prNumber) {
    this.octokit = octokit;
    this.owner = owner;
    this.repo = repo;
    this.prNumber = prNumber;
  }

  /**
   * Generate and post the performance report
   */
  async generateReport(results, urls, prNumber, repo) {
    const report = this.buildMarkdownReport(results, urls, prNumber, repo);
    const isVerificationRun = urls.isVerificationRun || false;
    
    try {
      await this.postComment(report, isVerificationRun);
      if (isVerificationRun) {
        console.log('Performance report updated (verification run)');
      } else {
        console.log('Performance report posted successfully');
      }
    } catch (error) {
      console.error('Error posting comment:', error.message);
      throw error;
    }
  }

  /**
   * Build the minimal markdown report for PR comment
   * Only shows issues in PR diff files (via inline comments)
   */
  buildMarkdownReport(results, urls, prNumber, repo) {
    const sections = [];

    // Header with issue count
    // If postedInlineComments is available, count only those (accurate count of files in PR diff)
    // Otherwise, count all newIssues (fallback for scheduled mode)
    const critical = this.countCriticalIssues(results, urls.postedInlineComments);
    
    if (critical === 0) {
      sections.push('## Performance Analysis\n');
      sections.push('**No critical issues found** - All checks passed!\n');
    } else {
      sections.push('## Performance Analysis\n');
      sections.push(`**${critical} critical issue${critical > 1 ? 's' : ''} found** - Please fix all issues shown as inline comments below.\n`);
    }
    
    sections.push('\n---');
    sections.push('*Generated by AEM Forms Performance Analyzer*');

    return sections.join('\n');
  }

  /**
   * Build AI Auto-Fix Suggestions section
   */
  buildAutoFixSuggestionsSection(autoFixData, autoFixCommit) {
    if (!autoFixData || !autoFixData.enabled || autoFixData.suggestions.length === 0) {
      return '';
    }

    const lines = ['### AI Auto-Fix Suggestions\n'];
    
    // INFO: Where to find inline annotations
    lines.push('> **Inline annotations available:** Go to **Checks** tab â†’ **"AEM Forms Performance Analysis"** to see AI suggestions directly on code lines\n');
    lines.push('');
    
    // AUTO-FIX COMMIT INFO (show prominently at top if applied)
    if (autoFixCommit) {
      lines.push(`> ### Auto-Fixes Applied to Current PR\n`);
      lines.push(`> **${autoFixCommit.filesChanged} file(s)** fixed in commit [\`${autoFixCommit.sha.substring(0, 7)}\`]\n`);
      lines.push('**Auto-applied fixes:**');
      autoFixCommit.files.forEach((file, i) => {
        lines.push(`${i + 1}. ${file}`);
      });
      lines.push('');
      lines.push('**Next Steps:**');
      lines.push('1. Pull the latest changes from your PR branch');
      lines.push('2. Test your form with the applied fixes');
      lines.push('3. Review the AI-generated code changes for correctness\n');
      lines.push('---\n');
    } else {
      lines.push(`> **${autoFixData.suggestions.length} performance improvement${autoFixData.suggestions.length > 1 ? 's' : ''} identified** â€” Review and apply to optimize your form\n`);
    }
    
    // Group by severity and fix type
    const critical = autoFixData.suggestions.filter(s => s.severity === 'critical');
    const high = autoFixData.suggestions.filter(s => s.severity === 'high');
    
    if (critical.length > 0) {
      lines.push('#### Critical Issues (Manual Refactoring Required)\n');
      lines.push('> These require code changes beyond simple comments. Follow the refactoring guides below.\n');
      critical.forEach((suggestion, index) => {
        lines.push(this.formatAutoFixSuggestion(suggestion, index + 1));
      });
    }
    
    if (high.length > 0) {
      lines.push('#### High Priority Issues\n');
      high.forEach((suggestion, index) => {
        lines.push(this.formatAutoFixSuggestion(suggestion, critical.length + index + 1));
      });
    }
    
    lines.push(`\n> *AI-powered fixes generated by ${autoFixData.provider === 'azure-openai' ? 'Azure OpenAI GPT-4.1' : autoFixData.provider}*\n`);
    
    return lines.join('\n');
  }

  /**
   * Format a single auto-fix suggestion
   */
  formatAutoFixSuggestion(suggestion, index) {
    const lines = [];
    
    lines.push(`<details>`);
    lines.push(`<summary><strong>${index}. ${suggestion.title}</strong></summary>\n`);
    
    lines.push(`**Issue:** ${suggestion.description}\n`);
    
    if (suggestion.estimatedImpact) {
      lines.push(`**Impact:** ${suggestion.estimatedImpact}\n`);
    }
    
    // JS Refactored Code (HTTP/DOM fixes) - REFERENCE CODE (manual application)
    if (suggestion.refactoredCode && (suggestion.type === 'custom-function-http-fix' || suggestion.type === 'custom-function-dom-fix')) {
      lines.push(`**File:** \`${suggestion.file}\`\n`);
      lines.push(`**Function:** \`${suggestion.functionName}()\`\n`);
      lines.push(`**Issue:** ${suggestion.description}\n`);
      
      // Different instructions for HTTP vs DOM fixes
      if (suggestion.type === 'custom-function-http-fix') {
        lines.push(`**Action Required:**\n`);
        lines.push(`1. **Refactor function code** (apply code below to remove HTTP call)\n`);
        lines.push(`2. **Add API integration** via Visual Rule Editor (see form JSON below)\n`);
      } else {
        lines.push(`**Action Required:**\n`);
        lines.push(`1. **Refactor function code** (apply code below to remove DOM access)\n`);
        lines.push(`2. **Create custom component** for DOM manipulation (see example below)\n`);
      }
      
      // Check if this will also appear as line-level comment with "Apply suggestion" button
      lines.push(`> â„¹ï¸ **Note:** This code is for reference. Copy and apply manually to your function.\n`);
      
      // Use javascript syntax (not 'suggestion') in main PR comment
      // 'suggestion' syntax only works in line-level comments, not in PR body
      lines.push('**Step 1: Refactored Function Code**\n');
      lines.push('```javascript');
      lines.push(suggestion.refactoredCode);
      lines.push('```\n');
      
      // Add form JSON if applicable (HTTP fixes)
      if (suggestion.formJsonSnippet) {
        lines.push(`**Step 2: Add to Form Events via Visual Rule Editor**\n`);
        lines.push('```json');
        lines.push(suggestion.formJsonSnippet);
        lines.push('```\n');
      }
      
      // Add component example if applicable (DOM fixes)
      if (suggestion.componentExample) {
        lines.push(`**Step 2: Custom Component Code**\n`);
        lines.push('```javascript');
        lines.push(suggestion.componentExample);
        lines.push('```\n');
      }
      
      lines.push(`**Note:** This suggestion is AI-generated. Review carefully before applying. File/line reference may not match PR diff but indicates the location in your branch.\n`);
    }
    // Runtime error fixes - APPLIED TO FILES
    else if (suggestion.refactoredCode && suggestion.type === 'custom-function-runtime-error-fix') {
      lines.push(`**File:** \`${suggestion.file}\`\n`);
      lines.push(`**Function:** \`${suggestion.functionName}()\`\n`);
      lines.push(`**Applied:** AI-generated null checks added automatically\n`);
      lines.push(`**Impact:** ${suggestion.impact}\n`);
    }
    // CSS Fixes with code
    else if (suggestion.file && suggestion.originalCode && suggestion.fixedCode) {
      lines.push(`**File:** \`${suggestion.file}:${suggestion.line}\`\n`);
      
      lines.push(`**Current Code:**`);
      lines.push('```css');
      lines.push(suggestion.originalCode);
      lines.push('```\n');
      
      lines.push(`**Suggested Fix:**`);
      lines.push('```css');
      lines.push(suggestion.fixedCode);
      lines.push('```\n');
      
      if (suggestion.htmlSuggestion) {
        lines.push(`**HTML Alternative:**`);
        lines.push('```html');
        lines.push(suggestion.htmlSuggestion);
        lines.push('```\n');
      }
      
      if (suggestion.alternativeFix) {
        lines.push(`**Alternative:** ${suggestion.alternativeFix}\n`);
      }
    }
    // Guidance-only fixes (for complex issues)
    else if (suggestion.guidance) {
      lines.push(`**How to Fix:**`);
      lines.push(suggestion.guidance);
      lines.push('');
    }
    
    // Fields to remove (for hidden fields)
    if (suggestion.fieldsToRemove && suggestion.fieldsToRemove.length > 0) {
      lines.push(`**Fields to Remove:**`);
      lines.push(suggestion.fieldsToRemove.map(f => `- \`${f}\``).join('\n'));
      lines.push('');
    }
    
    lines.push(`</details>\n`);
    
    return lines.join('\n');
  }

  /**
   * Build performance metrics section (form load time)
   */
  buildPerformanceMetricsSection(beforeData, afterData) {
    const lines = ['### Form Load Performance\n'];

    lines.push('| Metric | Before | After | Change | Status |');
    lines.push('|--------|--------|-------|--------|--------|');
    
    if (beforeData?.performanceMetrics && afterData?.performanceMetrics) {
      const before = beforeData.performanceMetrics;
      const after = afterData.performanceMetrics;
      
      const loadTimeDelta = after.loadTime - before.loadTime;
      const loadTimeChange = loadTimeDelta !== 0 ? `${loadTimeDelta > 0 ? '+' : ''}${loadTimeDelta}ms` : '0ms';
      
      // Determine status based on whether form rendered and load time
      let status = '';
      let beforeStatus = '';
      let afterStatus = '';
      
      // Check if forms actually loaded
      if (before.formRendered === false) {
        beforeStatus = ' (Failed)';
      }
      if (after.formRendered === false) {
        afterStatus = ' (Failed)';
        status = 'Failed';
      } else if (after.loadTime < 2000) {
        status = 'Fast';
      } else if (after.loadTime < 3000) {
        status = loadTimeDelta > 0 ? 'Slower' : 'Good';
      } else {
        status = 'Slow';
      }
      
      lines.push(`| **Form Render Time** | ${before.loadTime}ms${beforeStatus} | ${after.loadTime}ms${afterStatus} | ${loadTimeChange} | ${status} |`);
      
      if (before.Nodes && after.Nodes) {
        const nodesDelta = after.Nodes - before.Nodes;
        const nodesChange = nodesDelta !== 0 ? `${nodesDelta > 0 ? '+' : ''}${nodesDelta}` : '0';
        lines.push(`| **DOM Nodes** | ${before.Nodes} | ${after.Nodes} | ${nodesChange} | - |`);
      }
      
      if (before.JSHeapUsedSize && after.JSHeapUsedSize) {
        const heapBefore = (before.JSHeapUsedSize / 1024 / 1024).toFixed(1);
        const heapAfter = (after.JSHeapUsedSize / 1024 / 1024).toFixed(1);
        const heapDelta = ((after.JSHeapUsedSize - before.JSHeapUsedSize) / 1024 / 1024).toFixed(1);
        lines.push(`| **JS Heap Size** | ${heapBefore}MB | ${heapAfter}MB | ${heapDelta > 0 ? '+' : ''}${heapDelta}MB | - |`);
      }
    }
    
    return lines.join('\n');
  }

  /**
   * Build form structure section
   */
  buildFormStructureSection(formAnalysis) {
    const lines = ['### Form Structure\n'];

    if (formAnalysis.before && formAnalysis.after) {
      const { delta, newIssues, resolvedIssues } = formAnalysis;

      lines.push('| Metric | Before | After | Change |');
      lines.push('|--------|--------|-------|--------|');
      lines.push(`| Components | ${formAnalysis.before.components.total} | ${formAnalysis.after.components.total} | ${this.formatDelta(delta.components)} |`);
      lines.push(`| Event Handlers | ${formAnalysis.before.events.total} | ${formAnalysis.after.events.total} | ${this.formatDelta(delta.events)} |`);
      lines.push(`| Max Nesting Depth | ${formAnalysis.before.components.maxDepth} | ${formAnalysis.after.components.maxDepth} | ${this.formatDelta(delta.maxDepth)} |\n`);

      // New issues
      if (newIssues.length > 0) {
        lines.push('#### New Issues\n');
        newIssues.forEach(issue => {
          lines.push(`- **[${issue.severity.toUpperCase()}] ${issue.type}**: ${issue.message}`);
        });
        lines.push('');
      }

      // Resolved issues
      if (resolvedIssues.length > 0) {
        lines.push('#### Resolved Issues\n');
        resolvedIssues.forEach(issue => {
          lines.push(`- **${issue.type}**: ${issue.message}`);
        });
        lines.push('');
      }
    }

    return lines.join('\n');
  }

  /**
   * Build form events section (API calls in initialize)
   */
  buildFormEventsSection(formEvents) {
    const lines = ['### Form Events Analysis\n'];

    const { newIssues, resolvedIssues, after } = formEvents;

    // New issues - show concisely
    if (newIssues && newIssues.length > 0) {
      lines.push('#### Critical: API Calls in Initialize Events\n');
      lines.push(`**${newIssues.length} field(s) making API calls in initialize - this blocks form rendering:**\n`);
      
      // Group unique fields
      const uniqueFields = [...new Set(newIssues.map(i => i.field))];
      
      uniqueFields.forEach(field => {
        const apiCall = after.apiCallsInInitialize.find(a => a.field === field);
        if (apiCall) {
          lines.push(`- **\`${field}\`** (\`${apiCall.path}\`) - ${apiCall.apiCallType}`);
          lines.push(`  Expression: \`${apiCall.expression.substring(0, 80)}...\``);
        }
      });
      
      lines.push('');
      lines.push('**Recommendation:** Use **Visual Rule Editor** to move API calls from `initialize` event to `custom:formViewInitialized` event (triggered after form renders). Initialize events should only set up initial state, not fetch data.\n');
    }

    // Resolved issues
    if (resolvedIssues && resolvedIssues.length > 0) {
      lines.push('#### Fixed: API Calls Moved from Initialize\n');
      resolvedIssues.forEach(issue => {
        lines.push(`- Field \`${issue.field}\` - API call removed from initialize event`);
      });
      lines.push('');
    }

    if (!after || (after.apiCallsInInitialize && after.apiCallsInInitialize.length === 0)) {
      lines.push(' No API calls found in initialize events.\n');
    }

    return lines.join('\n');
  }

  /**
   * Build hidden fields section
   */
  buildHiddenFieldsSection(hiddenFields) {
    const lines = ['### Hidden Fields Analysis\n'];

    const { delta, newIssues, resolvedIssues, after } = hiddenFields;

    if (after) {
      lines.push(`**Total Hidden Fields:** ${after.totalHiddenFields}`);
      lines.push(`**Unnecessary Hidden Fields:** ${after.unnecessaryHiddenFields}\n`);

      if (delta && (delta.hiddenFields !== 0 || delta.unnecessaryFields !== 0)) {
        lines.push('**Changes:**');
        if (delta.hiddenFields !== 0) {
          lines.push(`- Hidden fields: ${this.formatDelta(delta.hiddenFields)}`);
        }
        if (delta.unnecessaryFields !== 0) {
          lines.push(`- Unnecessary fields: ${this.formatDelta(delta.unnecessaryFields)}`);
        }
        lines.push('');
      }
    }

    // New issues - show concisely
    if (newIssues && newIssues.length > 0) {
      lines.push('#### Unnecessary Hidden Fields\n');
      
      // Show first 10 field names inline
      const visibleCount = Math.min(10, newIssues.length);
      const fieldNames = newIssues.slice(0, visibleCount).map(i => `\`${i.field}\``).join(', ');
      
      lines.push(`**${newIssues.length} field(s) are always hidden and never made visible:**\n`);
      lines.push(fieldNames + (newIssues.length > visibleCount ? ', ...' : '') + '\n');
      
      // Put remaining fields in collapsible section
      if (newIssues.length > visibleCount) {
        lines.push(`<details>\n<summary>Show all ${newIssues.length} fields</summary>\n`);
        const allFields = newIssues.map(i => `- \`${i.field}\``).join('\n');
        lines.push(allFields);
        lines.push('\n</details>\n');
      }
      
      lines.push('**Recommendation:** Use **Visual Rule Editor** to replace hidden fields with Form Variables (`setVariable()` instead of field-based storage). Remove the hidden fields from form JSON. Hidden fields that are never shown bloat the DOM (each adds ~50-100 bytes) and slow down rendering. Configure state management via the rule editor\'s variable actions.\n');
    }

    // Resolved issues
    if (resolvedIssues && resolvedIssues.length > 0) {
      lines.push(` **Fixed:** ${resolvedIssues.length} unnecessary hidden field(s) removed\n`);
    }

    if (!after || after.unnecessaryHiddenFields === 0) {
      lines.push(' No unnecessary hidden fields detected.\n');
    }

    return lines.join('\n');
  }

  /**
   * Build rule cycles section
   */
  buildRuleCyclesSection(ruleCycles) {
    const lines = ['### Rule Performance Analysis\n'];

    const { newCycles, resolvedCycles, after, slowRules, slowRuleCount } = ruleCycles;

    // Handle error case first
    if (after && after.error) {
      lines.push(` Error analyzing rule cycles: ${after.error}\n`);
      return lines.join('\n');
    }

    // Show summary stats (always show if we have data)
    if (after) {
      lines.push(`**Total Rules:** ${after.totalRules || 0}`);
      lines.push(`**Fields with Rules:** ${after.fieldsWithRules || 0}`);
      lines.push(`**Circular Dependencies:** ${after.cycles || 0}`);
      if (slowRuleCount > 0) {
        lines.push(`**Slow Rules:** ${slowRuleCount} (> 50ms execution)\n`);
      } else {
        lines.push('');
      }
    }

    // Show slow rules first (these impact every interaction)
    if (slowRules && slowRules.length > 0) {
      lines.push('#### Slow Rule Execution\n');
      lines.push(`**${slowRuleCount} rule(s) take > 50ms to execute** - these slow down form interactions.\n`);
      
      // Show top 5 slowest
      const top5 = slowRules.slice(0, 5);
      top5.forEach(rule => {
        lines.push(`- **\`${rule.field}\`** - ${rule.duration}ms`);
        lines.push(`  Event: ${rule.event}, Expression: \`${rule.expression.substring(0, 60)}...\``);
      });
      
      if (slowRuleCount > 5) {
        lines.push(`\n*... and ${slowRuleCount - 5} more slow rule(s)*`);
      }
      
      lines.push('');
      lines.push('** Recommendation:** Optimize these rules by reducing complex computations, caching results, or moving expensive operations to custom events.\n');
    }

    // Show ALL cycles (from newCycles which contains after.cycleDetails)
    if (newCycles && newCycles.length > 0) {
      lines.push('#### Critical: Circular Dependencies Detected\n');
      
      newCycles.forEach((cycle, index) => {
        const cycleFields = cycle.fields || cycle.path || ['unknown'];
        lines.push(`**Cycle ${index + 1}:** \`${cycleFields.join(' â†’ ')}\``);
      });
      lines.push('');
      lines.push('** Recommendation:** Break circular dependencies immediately - these cause infinite loops and severely impact performance.\n');
    }

    // If no cycles detected, show success message
    if (!newCycles || newCycles.length === 0) {
      lines.push('No circular dependencies detected.\n');
    }

    // Resolved cycles
    if (resolvedCycles && resolvedCycles.length > 0) {
      lines.push('#### Resolved Circular Dependencies\n');
      resolvedCycles.forEach(cycle => {
        lines.push(`- \`${cycle.fields.join(' â†’ ')}\``);
      });
      lines.push('');
    }

    if (!after || (!after.error && (after.cycles === 0 || !after.cycles))) {
      lines.push(' No circular dependencies detected.\n');
    }

    return lines.join('\n');
  }

  /**
   * Build form validation errors section
   * Shows dataRef parsing errors and type conflicts from af-core
   */
  buildFormValidationSection(ruleCycles) {
    const lines = ['### Form Validation Warnings\n'];
    
    const { after } = ruleCycles || {};
    
    if (!after || !after.validationErrors || after.validationErrorCount === 0) {
      lines.push(' No form validation warnings.\n');
      return lines.join('\n');
    }
    
    const { validationErrors } = after;
    const { dataRefErrors, typeConflicts } = validationErrors;
    
    // DataRef Parsing Errors
    if (dataRefErrors && dataRefErrors.length > 0) {
      lines.push(`#### Invalid dataRef Syntax (${dataRefErrors.length})\n`);
      lines.push(`**Issue:** Fields have invalid JSONPath in \`dataRef\` property. Their data won't be exported in form submissions.\n`);
      
      // Show first 3 errors
      const displayErrors = dataRefErrors.slice(0, 3);
      displayErrors.forEach(error => {
        lines.push(`- Field \`${error.fieldId}\` â†’ Invalid dataRef: \`"${error.dataRef}"\``);
      });
      
      if (dataRefErrors.length > 3) {
        lines.push(`- ... and ${dataRefErrors.length - 3} more\n`);
      } else {
        lines.push('');
      }
      
      lines.push('**Fix in AEM Forms Editor:** Update \`dataRef\` to valid JSONPath (e.g., \`$.${error.dataRef}\` or \`data.${error.dataRef}\`) or remove it to use field \`name\` instead.\n');
    }
    
    // Type Conflict Errors
    if (typeConflicts && typeConflicts.length > 0) {
      lines.push(`#### Data Type Conflicts (${typeConflicts.length})\n`);
      lines.push(`**Issue:** Multiple fields are mapped to the same \`dataRef\` but have different data types. This causes type coercion and potential data loss.\n`);
      
      // Show first 3 conflicts
      const displayConflicts = typeConflicts.slice(0, 3);
      displayConflicts.forEach(conflict => {
        lines.push(`- \`${conflict.dataRef}\` â†’ Field \`${conflict.newField}\` (${conflict.newFieldType}) conflicts with: ${conflict.conflictingFields}`);
      });
      
      if (typeConflicts.length > 3) {
        lines.push(`- ... and ${typeConflicts.length - 3} more\n`);
      } else {
        lines.push('');
      }
      
      lines.push('**Fix in AEM Forms Editor:** Either use unique \`dataRef\` for each field, or ensure all fields bound to the same \`dataRef\` have matching types.\n');
    }
    
    return lines.join('\n');
  }

  /**
   * Build form HTML section
   */
  buildFormHTMLSection(formHTML, urls) {
    const lines = ['### Form Rendering Performance\n'];

    const { newIssues, resolvedIssues, after, delta } = formHTML;
    
    // Check if form actually rendered
    const formRendered = urls?.afterData?.performanceMetrics?.formRendered !== false;

    if (!formRendered) {
      lines.push('** Form failed to render - HTML analysis unavailable**\n');
      lines.push('The form did not load within 15 seconds, so we cannot analyze the rendered HTML.');
      lines.push('See "Form Load Performance" section above for investigation steps.\n');
      return lines.join('\n');
    }

    if (after && after.rendering) {
      lines.push('**Rendered Form Analysis:**');
      lines.push(`- Total DOM Elements: ${after.rendering.totalElements}`);
      lines.push(`- Hidden Elements: ${after.rendering.hiddenElements}`);
      lines.push(`- Images: ${after.images.total} (${after.images.nonLazyLoaded} without lazy loading)`);
      lines.push(`- Blocking Scripts: ${after.scripts.blocking}\n`);

      if (delta) {
        const hasChanges = delta.images !== 0 || delta.nonLazyImages !== 0 || 
                          delta.totalElements !== 0 || delta.blockingScripts !== 0;
        
        if (hasChanges) {
          lines.push('**Changes:**');
          if (delta.images !== 0) {
            lines.push(`- Images: ${this.formatDelta(delta.images)}`);
          }
          if (delta.nonLazyImages !== 0) {
            lines.push(`- Non-lazy images: ${this.formatDelta(delta.nonLazyImages)}`);
          }
          if (delta.totalElements !== 0) {
            lines.push(`- DOM elements: ${this.formatDelta(delta.totalElements)}`);
          }
          if (delta.blockingScripts !== 0) {
            lines.push(`- Blocking scripts: ${this.formatDelta(delta.blockingScripts)}`);
          }
          lines.push('');
        }
      }
    }

    // New issues
    if (newIssues && newIssues.length > 0) {
      lines.push('#### Form Rendering Issues\n');
      newIssues.forEach(issue => {
        lines.push(`**${this.getSeverityEmoji(issue.severity)} ${issue.type}**`);
        lines.push(`- **Issue:** ${issue.message}`);
        if (issue.images && issue.images.length > 0) {
          lines.push(`- **Images:** ${issue.images.slice(0, 3).join(', ')}${issue.images.length > 3 ? '...' : ''}`);
        }
        if (issue.recommendation) {
          lines.push(`- ** Recommendation:** ${issue.recommendation}`);
        }
        lines.push('');
      });
    }

    // Resolved issues
    if (resolvedIssues && resolvedIssues.length > 0) {
      lines.push('#### Resolved Form Rendering Issues\n');
      resolvedIssues.forEach(issue => {
        lines.push(`- **${issue.type}**: ${issue.message}`);
      });
      lines.push('');
    }

    if (!after || (after.issues && after.issues.length === 0)) {
      lines.push(' No form rendering issues detected.\n');
    }

    return lines.join('\n');
  }

  /**
   * Build form CSS section
   */
  buildFormCSSSection(formCSS) {
    const lines = ['### Form CSS Analysis\n'];

    const { after, newIssues } = formCSS;

    if (after) {
      lines.push(`**Files Analyzed:** ${after.filesAnalyzed}\n`);
    }

    // Show only critical issues in detail, summarize warnings
    if (newIssues && newIssues.length > 0) {
      const criticalIssues = newIssues.filter(i => i.severity === 'error');
      const warningIssues = newIssues.filter(i => i.severity === 'warning');
      
      // Critical issues - show details
      if (criticalIssues.length > 0) {
        lines.push('** Critical Issues:**\n');
        criticalIssues.forEach(issue => {
          lines.push(`- **${issue.file}** - ${issue.type}`);
        });
        lines.push('');
      }

      // Warnings - just count by type
      if (warningIssues.length > 0) {
        lines.push('** Warnings:**');
        const bgImages = warningIssues.filter(i => i.type === 'css-background-image').length;
        if (bgImages > 0) {
          lines.push(`- ${bgImages} CSS background-image(s) (use Image component instead)`);
        }
        lines.push(`- ${warningIssues.length} total warning(s)\n`);
      }
    }

    if (!newIssues || newIssues.length === 0) {
      lines.push(' No CSS issues detected.\n');
    }

    return lines.join('\n');
  }

  /**
   * Build custom functions section
   */
  buildCustomFunctionsSection(customFunctions) {
    const lines = ['### Custom Functions Analysis\n'];

    const { before, after, newIssues, resolvedIssues } = customFunctions;

    if (after && after.functionsAnalyzed > 0) {
      lines.push(`**Custom Functions Analyzed:** ${after.functionsAnalyzed}\n`);
    }

    // Show all violations in current state
    if (newIssues && newIssues.length > 0) {
      lines.push('#### Violations Detected\n');
      
      const domAccessIssues = newIssues.filter(i => i.type === 'dom-access-in-custom-function');
      const httpRequestIssues = newIssues.filter(i => i.type === 'http-request-in-custom-function');
      const runtimeErrorIssues = newIssues.filter(i => i.type === 'runtime-error-in-custom-function');

      if (httpRequestIssues.length > 0) {
        lines.push(`** ${httpRequestIssues.length} HTTP Request(s) in Custom Functions:**\n`);
        httpRequestIssues.forEach(issue => {
          lines.push(`- \`${issue.functionName}\` in \`${issue.file}\``);
          lines.push(`  - ${issue.recommendation}`);
        });
        lines.push('');
      }

      if (domAccessIssues.length > 0) {
        lines.push(`** ${domAccessIssues.length} DOM Access(es) in Custom Functions:**\n`);
        domAccessIssues.forEach(issue => {
          lines.push(`- \`${issue.functionName}\` in \`${issue.file}\``);
          lines.push(`  - ${issue.recommendation}`);
        });
        lines.push('');
      }

      if (runtimeErrorIssues.length > 0) {
        lines.push(`**${runtimeErrorIssues.length} Runtime Error(s) in Custom Functions:**\n`);
        lines.push('Functions encountered errors during execution (likely due to missing null checks):\n');
        runtimeErrorIssues.forEach(issue => {
          const errorSummary = issue.errors && issue.errors.length > 0 ? issue.errors[0] : 'Unknown error';
          lines.push(`- \`${issue.functionName}()\` - ${issue.errorCount} error(s): ${errorSummary}`);
        });
        lines.push('');
        lines.push('**Recommendation:** Add null/undefined checks before accessing properties. These errors occur when functions don\'t handle missing data gracefully. Can be auto-fixed by AI.\n');
      }
    }

    // Show resolved violations
    if (resolvedIssues && resolvedIssues.length > 0) {
      lines.push(` **Resolved:** ${resolvedIssues.length} custom function violation(s) fixed\n`);
    }

    if ((!newIssues || newIssues.length === 0) && (!resolvedIssues || resolvedIssues.length === 0)) {
      lines.push(' No custom function violations detected.\n');
    }

    return lines.join('\n');
  }

  /**
   * Build summary section
   */
  buildFormSummarySection(results) {
    const lines = ['\n---\n### Overall Assessment\n'];

    // Calculate overall impact
    const impact = this.calculateFormImpact(results);
    
    lines.push(`**Performance Impact:** ${impact.rating} ${impact.emoji}\n`);
    
    if (impact.critical.length > 0) {
      lines.push('** Critical Issues:**');
      impact.critical.forEach(c => lines.push(`- ${c}`));
      lines.push('');
    }

    if (impact.warnings.length > 0) {
      lines.push('** Warnings:**');
      impact.warnings.forEach(w => lines.push(`- ${w}`));
      lines.push('');
    }

    if (impact.positives.length > 0) {
      lines.push('** Improvements:**');
      impact.positives.forEach(p => lines.push(`- ${p}`));
      lines.push('');
    }

    if (impact.recommendations.length > 0) {
      lines.push('** Recommendations:**');
      impact.recommendations.forEach(r => lines.push(`- ${r}`));
    }

    return lines.join('\n');
  }

  /**
   * Calculate overall form performance impact
   */
  calculateFormImpact(results) {
    const impact = {
      rating: 'Neutral',
      emoji: '',
      critical: [],
      warnings: [],
      positives: [],
      recommendations: [],
    };

    let score = 0;

    // Form structure impact
    if (results.formStructure && results.formStructure.delta) {
      const { delta, newIssues, resolvedIssues } = results.formStructure;

      if (resolvedIssues && resolvedIssues.length > 0) {
        impact.positives.push(`Resolved ${resolvedIssues.length} form structure issue(s)`);
        score += resolvedIssues.length * 5;
      }
      
      if (newIssues && newIssues.length > 0) {
        impact.warnings.push(`${newIssues.length} new form structure issue(s)`);
        score -= newIssues.length * 5;
      }
    }

    // API calls in initialize
    if (results.formEvents) {
      const { newIssues, resolvedIssues } = results.formEvents;
      
      if (newIssues && newIssues.length > 0) {
        impact.critical.push(`${newIssues.length} API call(s) in initialize events - blocks form rendering`);
        impact.recommendations.push('Move API calls from initialize to custom events or lazy load after render');
        score -= newIssues.length * 30;
      }

      if (resolvedIssues && resolvedIssues.length > 0) {
        impact.positives.push(`Moved ${resolvedIssues.length} API call(s) out of initialize events`);
        score += resolvedIssues.length * 30;
      }
    }

    // Hidden fields
    if (results.hiddenFields) {
      const { delta, newIssues, resolvedIssues } = results.hiddenFields;
      
      if (newIssues && newIssues.length > 0) {
        impact.warnings.push(`${newIssues.length} unnecessary hidden field(s) bloating DOM`);
        impact.recommendations.push('Remove hidden fields that are never shown - use Form variables instead');
        score -= newIssues.length * 10;
      }

      if (resolvedIssues && resolvedIssues.length > 0) {
        impact.positives.push(`Removed ${resolvedIssues.length} unnecessary hidden field(s)`);
        score += resolvedIssues.length * 10;
      }
    }

    // Rule cycles and slow rules
    if (results.ruleCycles && !results.ruleCycles.after?.error) {
      const { newCycles, resolvedCycles, after, slowRuleCount } = results.ruleCycles;
      
      if (newCycles && newCycles.length > 0) {
        impact.critical.push(`${newCycles.length} circular dependenc${newCycles.length > 1 ? 'ies' : 'y'} - can cause infinite loops`);
        impact.recommendations.push('Break circular dependencies immediately - these cause severe performance issues');
        score -= newCycles.length * 50;
      }

      if (resolvedCycles && resolvedCycles.length > 0) {
        impact.positives.push(`Resolved ${resolvedCycles.length} circular dependenc${resolvedCycles.length > 1 ? 'ies' : 'y'}`);
        score += resolvedCycles.length * 50;
      }

      if (after && after.cycles > 0 && !newCycles?.length) {
        impact.warnings.push(`${after.cycles} existing circular dependenc${after.cycles > 1 ? 'ies' : 'y'} still present`);
      }
      
      // Slow rules (CRITICAL - blocks interactions)
      if (slowRuleCount > 0) {
        impact.critical.push(`${slowRuleCount} slow rule(s) detected (> 50ms execution) - blocks form interactions`);
        impact.recommendations.push('Optimize slow rules: reduce computations, or defer this rule until after form renders');
        score -= slowRuleCount * 20;
      }
    }

    // Form HTML rendering
    if (results.formHTML && !results.formHTML.error) {
      const { newIssues, resolvedIssues, delta } = results.formHTML;
      
      if (newIssues && newIssues.length > 0) {
        const criticalHTML = newIssues.filter(i => i.severity === 'error');
        const warningHTML = newIssues.filter(i => i.severity === 'warning');
        
        if (criticalHTML.length > 0) {
          impact.critical.push(`${criticalHTML.length} critical form rendering issue(s)`);
          score -= criticalHTML.length * 15;
        }
        
        if (warningHTML.length > 0) {
          impact.warnings.push(`${warningHTML.length} form rendering warning(s)`);
          score -= warningHTML.length * 5;
        }
        
        // Specific issues
        const nonLazyImages = newIssues.find(i => i.type === 'images-not-lazy-loaded');
        if (nonLazyImages) {
          impact.warnings.push(`${nonLazyImages.count} image(s) in form without lazy loading`);
          impact.recommendations.push('Add loading="lazy" to form images to improve rendering performance');
        }
        
        const blockingScripts = newIssues.find(i => i.type === 'blocking-scripts-in-form');
        if (blockingScripts) {
          impact.critical.push(`${blockingScripts.count} blocking script(s) in form`);
          impact.recommendations.push('Add async/defer to scripts or load after form renders');
        }
      }

      if (resolvedIssues && resolvedIssues.length > 0) {
        impact.positives.push(`Resolved ${resolvedIssues.length} form rendering issue(s)`);
        score += resolvedIssues.length * 10;
      }
    }

    // Form CSS issues
    if (results.formCSS && results.formCSS.after) {
      const { newIssues, after } = results.formCSS;
      
      if (newIssues && newIssues.length > 0) {
        const criticalCSS = newIssues.filter(i => i.severity === 'error');
        const warningCSS = newIssues.filter(i => i.severity === 'warning');
        
        if (criticalCSS.length > 0) {
          impact.critical.push(`${criticalCSS.length} critical CSS issue(s)`);
          score -= criticalCSS.length * 10;
        }
        
        if (warningCSS.length > 0) {
          impact.warnings.push(`${warningCSS.length} CSS warning(s)`);
          score -= warningCSS.length * 3;
        }
        
        // Specific CSS issues
        const backgroundImages = newIssues.filter(i => i.type === 'css-background-image');
        if (backgroundImages.length > 0) {
          impact.warnings.push(`${backgroundImages.length} CSS background-image(s) should use Image component`);
          impact.recommendations.push('Replace CSS background images with <Image> component for lazy loading and optimization');
        }
        
        const blockingImports = newIssues.filter(i => i.type === 'css-import-blocking');
        if (blockingImports.length > 0) {
          impact.critical.push(`${blockingImports.length} @import statement(s) blocking rendering`);
          impact.recommendations.push('Replace @import with <link> tags or bundle CSS');
        }
      }

      // Summary stats
      if (after.summary) {
        if (after.summary.backgroundImages > 0) {
          // Already handled above
        }
        if (after.summary.importantRules > 50) {
          impact.warnings.push(`Excessive !important usage (${after.summary.importantRules} times)`);
        }
      }
    }

    // Custom Functions violations
    if (results.customFunctions && !results.customFunctions.error) {
      const { newIssues, resolvedIssues } = results.customFunctions;
      
      if (newIssues && newIssues.length > 0) {
        const domAccessIssues = newIssues.filter(i => i.type === 'dom-access-in-custom-function');
        const httpRequestIssues = newIssues.filter(i => i.type === 'http-request-in-custom-function');
        
        if (domAccessIssues.length > 0) {
          impact.critical.push(`${domAccessIssues.length} custom function(s) accessing DOM directly`);
          impact.recommendations.push('Remove DOM access from custom functions - use form data model instead');
          score -= domAccessIssues.length * 40;
        }
        
        if (httpRequestIssues.length > 0) {
          impact.critical.push(`${httpRequestIssues.length} custom function(s) making HTTP requests`);
          impact.recommendations.push('Use request() API tool instead of direct HTTP calls in custom functions');
          score -= httpRequestIssues.length * 30;
        }
      }

      if (resolvedIssues && resolvedIssues.length > 0) {
        impact.positives.push(`Fixed ${resolvedIssues.length} custom function violation(s)`);
        score += resolvedIssues.length * 35;
      }
    }

    // Determine overall rating
    if (score > 20) {
      impact.rating = 'Positive';
      impact.emoji = '';
    } else if (score < -20) {
      impact.rating = 'Negative';
      impact.emoji = '';
    } else {
      impact.rating = 'Neutral';
      impact.emoji = '';
    }

    // Add critical marker if severe issues exist
    if (impact.critical.length > 0) {
      impact.rating = 'Critical Issues Detected';
      impact.emoji = '';
    }

    return impact;
  }

  /**
   * Format delta with sign
   */
  formatDelta(value) {
    if (value === 0) return '0';
    const sign = value > 0 ? '+' : '';
    const emoji = value > 0 ? '' : value < 0 ? '' : '';
    return `${sign}${value} ${emoji}`;
  }

  /**
   * Get emoji for severity
   */
  getSeverityEmoji(severity) {
    const map = {
      error: '',
      warning: '',
      info: '',
    };
    return map[severity] || '';
  }

  /**
   * Post or update comment on PR
   * On verification runs, finds and updates existing bot comment to prevent duplicates
   */
  async postComment(body, isVerificationRun = false) {
    if (isVerificationRun) {
      // Find existing bot comment and update it
      try {
        const { data: comments } = await this.octokit.rest.issues.listComments({
          owner: this.owner,
          repo: this.repo,
          issue_number: this.prNumber,
        });
        
        // Find the most recent bot comment (contains bot signature)
        const botComment = comments
          .reverse() // Start from most recent
          .find(c => c.body && c.body.includes('ðŸ¤– **AEM Forms Performance Analysis'));
        
        if (botComment) {
          // Update existing comment
          await this.octokit.rest.issues.updateComment({
            owner: this.owner,
            repo: this.repo,
            comment_id: botComment.id,
            body,
          });
          console.log(`Updated existing PR comment #${botComment.id}`);
          return;
        }
      } catch (error) {
        console.warn(`Could not update existing comment: ${error.message}`);
        // Fall through to create new comment
      }
    }
    
    // Create new comment (default behavior or fallback)
    await this.octokit.rest.issues.createComment({
      owner: this.owner,
      repo: this.repo,
      issue_number: this.prNumber,
      body,
    });
  }

  /**
   * Count critical issues
   * @param {Object} results - All analyzer results
   * @param {Array} postedInlineComments - Successfully posted inline comments (if available)
   * @returns {number} Count of critical issues
   */
  countCriticalIssues(results, postedInlineComments = null) {
    // If we have postedInlineComments, count only those (accurate count of files in PR diff)
    if (postedInlineComments && Array.isArray(postedInlineComments)) {
      // Count unique functions/files that got inline comments posted
      // This is the ACCURATE count of issues in PR diff files
      return postedInlineComments.length;
    }
    
    // Fallback: Count all newIssues (for scheduled mode or if inline comments not available)
    // In PR mode, count ONLY issues in PR diff files (newIssues arrays)
    // These are already filtered by filterResultsToPRFiles()
    let count = 0;
    
    // Form events (already filtered to PR)
    if (results.formEvents?.newIssues?.length) {
      count += results.formEvents.newIssues.length;
    }
    
    // Custom functions (only PR diff files)
    if (results.customFunctions?.newIssues?.length) {
      count += results.customFunctions.newIssues.length;
    }
    
    // CSS (only PR diff files)
    if (results.formCSS?.newIssues?.length) {
      count += results.formCSS.newIssues.length;
    }
    
    // HTML (only PR diff - URL-based, always shown)
    if (results.formHTML?.newIssues?.length) {
      count += results.formHTML.newIssues.length;
    }
    
    // Rule cycles (only if form JSON in PR)
    if (results.ruleCycles?.newIssues?.length) {
      count += results.ruleCycles.newIssues.length;
    }
    
    // Hidden fields (only if form JSON in PR)
    if (results.hiddenFields?.newIssues?.length) {
      count += results.hiddenFields.newIssues.length;
    }
    
    return count;
  }

  /**
   * Count warnings
   */
  countWarnings(results) {
    let count = 0;
    if (results.hiddenFields?.after?.unnecessaryHiddenFields) {
      count += results.hiddenFields.after.unnecessaryHiddenFields;
    }
    if (results.formCSS?.after?.issues?.filter(i => i.severity === 'warning').length) {
      count += results.formCSS.after.issues.filter(i => i.severity === 'warning').length;
    }
    if (results.formHTML?.after?.issues?.filter(i => i.severity === 'warning').length) {
      count += results.formHTML.after.issues.filter(i => i.severity === 'warning').length;
    }
    // Form validation errors (dataRef + type conflicts)
    if (results.ruleCycles?.after?.validationErrorCount) {
      count += results.ruleCycles.after.validationErrorCount;
    }
    return count;
  }

  /**
   * Get load status string
   */
  getLoadStatus(urls) {
    const after = urls.afterData?.performanceMetrics;
    if (!after) return 'Unknown';
    if (!after.formRendered) return `Failed (${Math.round(after.loadTime/1000)}s timeout)`;
    if (after.loadTime < 2000) return `${after.loadTime}ms (Fast)`;
    if (after.loadTime < 3000) return `${after.loadTime}ms (Good)`;
    return `${after.loadTime}ms (Slow)`;
  }

  /**
   * Build top priority actions section
   */
  buildTopActionsSection(results, urls) {
    const actions = [];
    let actionNum = 1;
    
    // Check what was auto-fixed
    const fixedFiles = new Set(urls.autoFixCommit?.files || []);
    const isFileFixed = (filename) => {
      return Array.from(fixedFiles).some(f => f.includes(filename));
    };

    // CSS critical issues (CSS imports, background-image)
    const cssCritical = results.formCSS?.after?.issues?.filter(i => i.severity === 'error') || [];
    if (cssCritical.length > 0) {
      const cssFilesWithIssues = [...new Set(cssCritical.map(i => i.file))];
      const cssFixed = cssFilesWithIssues.some(f => isFileFixed(f));
      const status = cssFixed ? '**âœ“ FIXED**' : '**[Action Required]**';
      actions.push(`${actionNum}. ${status} **CSS Critical** â†’ ${cssCritical.length} issue(s) blocking render (CSS @import, background-image)`);
      actionNum++;
    }

    // API calls in initialize events
    const apiCalls = results.formEvents?.after?.apiCallsInInitialize || [];
    if (apiCalls.length > 0) {
      actions.push(`${actionNum}. **[Action Required]** **API Blocking** â†’ ${apiCalls.length} initialize call(s) blocking render (move to events)`);
      actionNum++;
    }

    // HTTP requests in custom functions
    const httpCount = results.customFunctions?.after?.httpRequestCount || 0;
    if (httpCount > 0) {
      actions.push(`${actionNum}. **[Action Required]** **HTTP in Functions** â†’ ${httpCount} function(s) bypassing form API (use request())`);
      actionNum++;
    }

    // DOM access in custom functions
    const domCount = results.customFunctions?.after?.domAccessCount || 0;
    if (domCount > 0) {
      actions.push(`${actionNum}. **[Action Required]** **DOM Access** â†’ ${domCount} function(s) directly manipulating DOM (use setProperty)`);
      actionNum++;
    }

    // Runtime errors in custom functions
    const runtimeErrors = results.customFunctions?.after?.runtimeErrorCount || 0;
    if (runtimeErrors > 0) {
      const runtimeFixed = isFileFixed('functions.js');
      const status = runtimeFixed ? '**âœ“ FIXED**' : '**[Action Required]**';
      actions.push(`${actionNum}. ${status} **Runtime Errors** â†’ ${runtimeErrors} function(s) throwing errors (null/undefined checks needed)`);
      actionNum++;
    }

    // Rule cycles (circular dependencies)
    if (results.ruleCycles?.after?.cycles > 0) {
      actions.push(`${actionNum}. **[Action Required]** **Rule Cycles** â†’ ${results.ruleCycles.after.cycles} circular dependenc${results.ruleCycles.after.cycles > 1 ? 'ies' : 'y'} detected (break dependency chain)`);
      actionNum++;
    }

    // Slow rules (performance)
    const slowRules = results.ruleCycles?.after?.slowRuleCount || 0;
    if (slowRules > 0) {
      actions.push(`${actionNum}. **[Action Required]** **Slow Rules** â†’ ${slowRules} rule(s) taking >50ms (optimize rule logic)`);
      actionNum++;
    }

    // Non-lazy loaded images
    const nonLazyImages = results.formHTML?.after?.issues?.filter(i => i.type === 'images-not-lazy-loaded') || [];
    if (nonLazyImages.length > 0) {
      actions.push(`${actionNum}. **[Action Required]** **Non-Lazy Images** â†’ ${nonLazyImages.length} image(s) not lazy loaded (add loading="lazy")`);
      actionNum++;
    }

    // Blocking scripts
    const blockingScripts = results.formHTML?.after?.issues?.filter(i => i.type === 'blocking-scripts') || [];
    if (blockingScripts.length > 0) {
      actions.push(`${actionNum}. **[Action Required]** **Blocking Scripts** â†’ ${blockingScripts.length} script(s) blocking render (add defer/async)`);
      actionNum++;
    }

    // Form load failure (always show if present)
    if (urls.afterData?.performanceMetrics && !urls.afterData.performanceMetrics.formRendered) {
      actions.push(`${actionNum}. **[Action Required]** **Form Timeout** â†’ Form failed to load in 15s (check browser console for errors)`);
      actionNum++;
    }

    return actions.length > 0 ? actions.join('\n') + '\n' : '';
  }

  /**
   * Build quick stats section
   */
  buildQuickStatsSection(results, urls) {
    const lines = ['### Quick Stats\n'];
    
    const components = results.formStructure?.after?.components?.total || 0;
    const rules = results.ruleCycles?.after?.totalRules || 0;
    const cycles = results.ruleCycles?.after?.cycles || 0;
    const hidden = results.hiddenFields?.after?.unnecessaryHiddenFields || 0;
    const loadTime = urls.afterData?.performanceMetrics?.formRendered 
      ? `${urls.afterData.performanceMetrics.loadTime}ms`
      : 'Failed';

    lines.push(`- **Components:** ${components} | **Rules:** ${rules} (${cycles} cycles)`);
    lines.push(`- **Form Load:** ${loadTime} | **Hidden Fields:** ${hidden} unnecessary`);
    lines.push(`- **CSS Files:** ${results.formCSS?.after?.filesAnalyzed || 0} analyzed | **Custom Functions:** ${results.customFunctions?.after?.functionsAnalyzed || 0} analyzed`);
    
    return lines.join('\n');
  }
}

